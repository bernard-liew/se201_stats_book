# Data manipulation - part 2 {#WRANGLE2}

## Download and load packages {-}

```{r, message=FALSE, warning=FALSE}
if (!require("pacman")) install.packages("pacman")
pacman::p_load(tidyverse, # All purpose wrangling for dataframes
               openxlsx,# writing excel documents
               lubridate,# date-time 
               tibbletime) # moving average for vo2

```



```{r message=FALSE, warning=FALSE, echo = FALSE}


dat_fms <-  read.xlsx (xlsxFile = "data/fms_pt3.xlsx",
                   sheet = "Sheet1")

dat_fms_grp <- read.xlsx (xlsxFile = "data/simFMS.xlsx",
                   sheet = "FMS")

dat_vo2 <-  read.xlsx (xlsxFile = "data/treadmill_pt4.xlsx",
                   sheet = "raw")

dat_vo2_stage <-  read.xlsx (xlsxFile = "data/treadmill_pt4.xlsx",
                   sheet = "stage")

bad_leg_accl <-  read.xlsx (xlsxFile = "data/rightleg_imu.xlsx")

good_leg_accl <-  read.xlsx (xlsxFile = "data/leftleg_imu.xlsx")
```


```{r, echo = FALSE }
# New names. Notice the commas and be pedantic about spacing

new_names <- c("time", "bf", "vo2_norm", "rer", "vo2", "vco2", "ve", "hr")

# Give the new names to the old names

colnames (dat_vo2)  <- new_names

# This prints the new column names

colnames (dat_vo2)  
# This removes the first row, and replaces the old data in object dat_vo2

dat_vo2 <- dat_vo2 %>% 
  slice (-(1))

# This selects the vertical acceleration signal of the IMU of the bad leg

bad_vertical_accl <- bad_leg_accl %>%
  select ("highg_az_m/s/s")
# This selects the vertical acceleration signal of the IMU of the good leg

good_vertical_accl <- good_leg_accl %>%
  select ("highg_az_m/s/s")

# Make all variables from bf to hr numeric, and replace the current data

dat_vo2 <-  dat_vo2 %>%
  mutate (bf = as.numeric(bf),
          vo2_norm = as.numeric(vo2_norm),
          rer = as.numeric(rer),
          vo2 = as.numeric(vo2),
          vco2 = as.numeric(vco2),
          ve = as.numeric(ve),
          hr = as.numeric(hr))

dat_vo2 <- dat_vo2 %>%
  mutate (time = time %>% 
            str_squish() %>% # function strips any whitespaces
            ms() %>% # convert to minutes and seconds
            as.period(unit = "sec") %>% # converts entirely to seconds
            as.numeric ()) # strips the S symbol to make it a number

dat_vo2 <- dat_vo2 %>%
  mutate (stage = cut_interval(time, length = 210, labels = FALSE))

```



## Gathering {#WRANGLE2-GATHER}

```{r, echo = FALSE}
vembedr::embed_youtube("XVTX1L9iZIo", height = 400)
```

### Problem

You want to make your data longer. In the data `dat_fms_grp` (go to the start of this chapter to see this data's original shape), you want to merge the 7 columns indicating the 7 FMS tasks into a single column. For this, you can use the `pivot_longer()` function. 

### Solution

```{r }
dat_long <- dat_fms_grp %>% # original data
  pivot_longer(cols = -id,
              names_to = "task",
              values_to = "score")
```
```{r, echo = FALSE}
dat_long %>%
  knitr::kable (digits = 2) %>%
  kableExtra::scroll_box(width = "100%", height = "500px")
```

## Spreading {#WRANGLE2-SPREAD}

```{r, echo = FALSE}
vembedr::embed_youtube("utuxfSl1umU", height = 400)
```

### Problem

You want to make your data wider, in this instance let us look at the `dat_fms` dataset. You want to have one column indicating the left FMS score, and one indicating the right FMS score. The caveat is that because some tasks in the FMS do not have left and right, we need to remove the tasks in the FMS without a left and right. In this case, we will use the `filter()` function, which will be discussed in Recipe \@ref(WRANGLE2-FILTER).

```{r}
dat_fms_sub <- dat_fms %>%
  filter (side != "c")
```

### Solution

```{r }
dat_wide <- dat_fms_sub %>% # original data
  pivot_wider(names_from = "side",
              values_from = "score")

```
```{r, echo = FALSE}
dat_wide%>%
  knitr::kable (digits = 2)
```

## Rename values of a variable {#WRANGLE2-RENAME-VALUES}

```{r, echo = FALSE}
vembedr::embed_youtube("duTAu0314og", height = 400)
```

### Problem

You want to rename some values, either because it is too long, too short, or for other reasons. In this instance, in the `dat_fms` dataset, you want to call `l`, `left`, and `r`, `right`.

### Solution

Use the `mutate()` function and the `recode()` function. You will learn the `mutate ()` function more in Recipe \@ref(WRANGLE2-NEW-VARIABLES).

```{r }

dat_fms <- dat_fms %>%
  mutate (side = recode (side, # the variable name
                          "l" = "left", # old label = new label
                          "r" = "right")) # old label = new label

```

```{r, echo = FALSE}
dat_fms%>%
  knitr::kable (digits = 2)
```

## Creating factors {#WRANGLE2-CHARACTERS-2-FACTORS}

```{r, echo = FALSE}
vembedr::embed_youtube("B8WN5PzQRdk", height = 400)
```

### Problem

You want to create an order in the values of a variable - like small, medium, large. 

### Solution

```{r}
# Order of values I desire

new_lvls <- c( "push_up","squat", "rot_stab", "hurdle", "lunge", "leg_raise",  "shd_mob")

dat_fms_relvl <- dat_fms %>%
  mutate (task = factor (task, levels = new_lvls))


```

### Discussion

Why do you need to convert categorical variables to factors? For visualization, the simple reason is that it allows you to control the order in which items appear first to last. Of course, it has important statistical reasons, of which we do not discuss presently.

(ref:cap-FIG-BAR-GRAPH-FACTOR-EFFECTS) Barplots of FMS score on original `dat_fms` (top); and new `dat_fms_relvl` when with modified the `task` variable to be a factor, with new levels (bottom).

```{r FIG-BAR-GRAPH-FACTOR-EFFECTS, fig.show="hold", fig.cap="(ref:cap-FIG-BAR-GRAPH-FACTOR-EFFECTS)"}
# Without factor 

ggplot(dat_fms) +
  geom_col(aes(x = task, y = score, fill = side), position = "dodge", color = "black") 

# With factor new levels

ggplot(dat_fms_relvl) +
  geom_col(aes(x = task, y = score, fill = side), position = "dodge", color = "black") 

```


## Making a new variable {#WRANGLE2-NEW-VARIABLES}

```{r, echo = FALSE}
vembedr::embed_youtube("qyqt0CS19h4", height = 400)
```

### Problem

You want to create a new column which involves some math between columns

### Solution

Example, you want to create a column called `ratio` in the `dat_vo2` dataset, by dividing `vo2` by `vco2`.

```{r }
dat_vo2 <-  dat_vo2 %>%
  mutate (ratio = vo2/vco2) 

```

```{r, echo = FALSE}
head(dat_vo2)%>%
  knitr::kable (digits = 2)
```


### Discussion

There are many math operations you can do including subtraction (`-`), multiplication (`*`), addition (`+`), exponentiation/power to the power of 2 (`^2`). Let us go crazy and try some random creation of new variables.

```{r }

dat_vo2_crazy <-  dat_vo2  %>%
  mutate (vo2_power = vo2^3,# vo2 powered to 3 
          vco2_mod = vco2/3, # vco2 divied by 3
          junk = (vo2+ vco2)/ (hr + bf))# divided the sum of vo2 and vco2, and sum of hr and bf
  
```

```{r, echo = FALSE}
head(dat_vo2_crazy)%>%
  knitr::kable (digits = 2) 
```

You can even create a new variable, which reflects the present row number (`row_id`). This row number reflects the number of 5 sec VO2 windows. If there is 10 sec of data collected, there will be two row numbers, Really quite useful for VO2 analysis and cleaning. Here, inside the `mutate()` function, I will be using the function  `row_number()` to get the respective number for each row.

```{r}
dat_vo2 <- dat_vo2 %>%
  mutate (row_id = row_number())

```
```{r, echo = FALSE}
head(dat_vo2)%>%
  knitr::kable (digits = 2)
```

For the IMU data, you can automatically find the maximum value of a very long data sequence, and use these values to provide an index of landing impact symmetry.

```{r}

# Maximal bad leg impact value
max_bad_ampl <- max(bad_vertical_accl)

# Maximal good leg impact value
max_good_ampl <- max(good_vertical_accl)

```
```{r}

# Symmetry index 

symmmetry_index <- 
  ((2* (max_bad_ampl - max_good_ampl))/(max_bad_ampl + max_good_ampl)) * 100


symmmetry_index

```


## Filtering {#WRANGLE2-FILTER}

```{r, echo = FALSE}
vembedr::embed_youtube("-xKvvvsYAXw", height = 400)
```

Filtering is removing rows you do not want and keeping rows you want based on some condition(s). In Recipe \@ref(WRANGLE-SLICE), you learnt the `slice()` function. That is for really simple filtering. The `filter()` function you will learn here gives you more flexibility. Filtering deals with keeping or throwing out **rows** of data. Keeping or throwing out columns of data requires the `select()` function, which you learnt in Recipe \@ref(WRANGLE-SLICE).

### Keep rows you want based on condition {#WRANGLE2-FILTER-KEEP-CHARACTER}

#### Problem

In the `dat_fms` dataset, you want to keep rows that have `side == "left"` (i.e. only rows where the `side` value equals `left`). Note the `==`, double equal sign, instead of the usual `=`. In this short book, I will not go at length to explain why R is so difficult, only that I ask you to obey the rules of the language. 

#### Solution

```{r }

fms_left <- dat_fms %>%
  filter (side == "left") 
```

```{r, echo = FALSE}
fms_left%>%
  knitr::kable (digits = 2)
```


### Keep rows based on a numerical range {#WRANGLE2-FILTER-KEEP-NUMERIC}

You want to keep the data when a variable is within a certain window range. Let us use the `dat_vo2` dataset. Let us see the range of values of the variable `ve`.

```{r}
hist (dat_vo2$ve)
```

#### Problem

Say I want to keep rows where 1) `ve` is less than 80, 2) `ve` more than 40, and 3) `ve` is between 40 to 80.

#### Solution

Notice for each graph, how the minimum and maximum values have been clipped off.

```{r}
# Keep ve less than 80

dat_vo2_filt <- dat_vo2 %>%
  filter (ve < 80)

hist (dat_vo2_filt$ve)

# Keep ve lmore than 40

dat_vo2_filt <- dat_vo2 %>%
  filter (ve > 40)

hist (dat_vo2_filt$ve)

# Keep ve between 40 to 80

dat_vo2_filt <- dat_vo2 %>%
  filter (ve > 40 & ve < 80)

hist (dat_vo2_filt$ve)
```

### Discussion

`filter()` works really when you want to throw out or keep rows of data based on some ranges or criteria of the variables you have. When you want to keep rows of data based on the row number, use `slice ()`. See also Recipe \@ref(WRANGLE-SLICE).


## Global summary {#WRANGLE2-SUMMARIZE-GLOBAL}

```{r, echo = FALSE}
vembedr::embed_youtube("997159RN4Qg", height = 400)
```

### Problem

You want to find the total FMS score across all sides and tasks

### Solution

In the `dat_fms` dataset, we want to use the `summarize ()` function.

```{r }

dat_fms %>%
  summarize (total_score = sum (score)) 

```

I dare you to find an easier way to calculate such scores in one line of code. That is one reason why I use a programming language like R. It is fast!!!

### Discussion

We can also go berserk by trying out different summary functions, like `mean ()`, `median ()`, `min()` (minimum value), `max` (maximum value). The function `n()` is a really useful one to count the number of rows. If your rows indicate the number of subjects, `n()` essentially counts the number of subjects.

```{r }

fms_summ <- dat_fms %>%
  summarize (total_score = sum (score),
             mean_score = mean (score),
             median_score = median (score),
             min_score = min (score),
             max_score = max(score),
             count = n()) 
```

```{r, echo = FALSE}
fms_summ %>%
  knitr::kable (digits = 2)
```

## Group-by summary {#WRANGLE2-SUMMARIZE-GROUPBY}

```{r, echo = FALSE}
vembedr::embed_youtube("WzWUvmZ0JQU", height = 400)
```


### Problem

You want to perform the same summary function for each chunk of group. For example, the FMS is typically scored by taking the lower of the two values of left and right for each task. In `side`, we have three values, `c`, `left` and `right`. The minimum of `c` is the same value itself.

### Solution

In the `dat_fms_grp` dataset, we want to use the `group_by()` and `summarize ()` function. The code below reads as: collapse all tasks into a single column, for each task and each score, count the number of rows (subjects) who has that score. 

```{r }

fms_grp_summ <- dat_fms_grp %>%
  pivot_longer(cols = -id,
               names_to = "task",
               values_to = "score") %>%
  group_by(task, score) %>%
  summarize (count = n()) 

```

```{r, echo = FALSE}
fms_grp_summ  %>%
  knitr::kable (digits = 2)
```

### Discussion

Why do you need to learn to create summaries? It is the basis for generating plots easily. Let us look at the `dat_vo2` dataset. 

Remember in your lessons, the last 30 sec of each 3 min 30 sec **complete** stage is discarded. That means that I want to throw away the data interval between 3:00 to 3:30 min for every stage. 

Thereafter, for the **complete** stage, the last 30 sec of each 3 min interval is then averaged for further analysis. This means keeping data between 2:30 to 3:00 min of each stage. That corresponds to the last six rows of each stage (i.e. rows 31 to 36 of each stage). Try to think why i selected these row numbers! 

For the last stage, there may be the chance that it is **incomplete**. Based on Kelly's lesson, you will need to extract the last 30 sec (i.e. last six rows) of this last incomplete stage.

I then want to average all my variables over these 6 rows per stage. 

I should end up with a dataframe that has 8 rows given 8 stages, one for each stage in this example. 

```{r, results = "asis"}
dat_vo2_summ <- dat_vo2 %>%
  group_by(stage) %>% # for each group
  mutate (row_id = row_number()) %>%
  filter (row_id < 37) %>%
  slice_tail (n = 6) %>%
  summarise (bf = mean (bf),
             vo2_norm = mean (vo2_norm),
             rer = mean (rer),
             vo2 = mean (vo2),
             vco2 = mean (vco2),
             ve = mean (ve),
             hr = mean (hr))

```

```{r, echo = FALSE}
knitr::kable (dat_vo2_summ,
              digits = 2,
              caption = "Stage by stage VO2 analysis")
```

## Merge two tables together {#WRANGLE2-INNER-JOIN}

```{r, echo = FALSE}
vembedr::embed_youtube("g0Rrmur31MU", height = 400)
```
### Problem

You want to combine two tables together, ensuring that each row is linked appropriately. For example, you want to combine your `dat_vo2_summ` summary data with the `dat_vo2_stage` table which contains the RPE and blood lactate values. 

### Solution

Use the `inner_join` function, with the `by` key as the common identifier that must be in both dataframes. 

```{r }

dat_vo2_comb <- dat_vo2_summ %>%
  inner_join(dat_vo2_stage, by = "stage") 
  
```

```{r, echo = FALSE}
dat_vo2_comb %>%
  knitr::kable (digits = 2)
```

### Discussion
It is common sense, that if we want to join two tables, there must be some rules. First, if we want to join two tables side by side left-right, the number of rows must match. Second, there must be a way the computer knows how to join, much like a key and a keyhole. The key is the column to join by, in this example, `stage`. In the `dat_vo2_summ` there is the `stage` variable with identical number of levels `1-8`, and the same variable appears in `dat_vo2_stage`. You don't have to worry if after merging, the data is sorted correctly, if you follow these rules.

## Learning check {#WRANGLE2-LEARNING-CHECK}

```{r, echo = FALSE}
vembedr::embed_youtube("D0a18-ge5tE", height = 400)
```


1. From your learning check in \@ref(INPUT-LEARNING-CHECK), open up your `practice_script.R`. You should already have the codes to import the `data/Athlete_1_treadmill.xlsx` file, and label the data called `dat`.

2. Rename the columns of `dat` to be `("time", "bf", "vo2_norm", "rer", "vo2", "vco2", "ve", "hr")`, respectively. See Recipe \@ref(WRANGLE-RENAME-VARIABLES).

3. Remove the first row of the `dat` data, as it is useless. See Recipe \@ref(WRANGLE-SLICE).

4. Convert the variable `time` of `dat` into numeric seconds, and all other variables to numeric. See Recipe \@ref(WRANGLE-CHARACTER-2-TIME) and \@ref(WRANGLE-CHARACTER-2-NUMERIC), respectively.

5. Create a variable called `stage`, where each stage represents 3:30 min worth of VO2 data. See Recipe \@ref(WRANGLE-NUMERIC-CATEGORY).

6. For each stage, create a variable called `row_id`, which essentially represents the number of 5 sec windows in each stage. See Recipe \@ref(WRANGLE2-NEW-VARIABLES) and \@ref(WRANGLE2-SUMMARIZE-GROUPBY).

7. For each stage, remove the data between 3:00 to 3:30min. See Recipe \@ref(WRANGLE2-SUMMARIZE-GROUPBY) and \@ref(WRANGLE2-FILTER-KEEP-NUMERIC).

8. For each stage, keep the last six rows of data. See Recipe \@ref(WRANGLE2-SUMMARIZE-GROUPBY) and \@ref(WRANGLE-SLICE).

9. For each stage, calculate for all variables for the mean of the last six rows of data. See Recipe \@ref(WRANGLE2-SUMMARIZE-GROUPBY) and \@ref(WRANGLE2-SUMMARIZE-GLOBAL).

10. Save this cleaned data set into the `data/` folder called `Athlete_1_treadmill_clean.xlsx`. Go into this folder physically, and see this new excel file is there and open it. See Recipe \@ref(INPUT-EXPORT)

11. Download the solution to this learning check below.

```{r echo=FALSE}
downloadthis::download_file(
  path = "data/practice_manip.R",
  output_name = "Learning check 6 answers",
  output_extension = ".R",
  button_label = "Learning check 6 answers",
  button_type = "warning",
  has_icon = TRUE,
  icon = "fa fa-save"
 
)
```

