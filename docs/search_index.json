[
["index.html", "A Simple Cookbook for Wrangling and Visualization Chapter 1 Preface 1.1 Why is R so great? 1.2 Why R is like a relationship… 1.3 R resources", " A Simple Cookbook for Wrangling and Visualization Bernard Liew 2020-09-13 Chapter 1 Preface The purpose of this book is to help you CLEAN your data and produce AMAZING graphics EASILY but not fast at first. What this book is This books is intended to be a cookbook based approach. It has problems and it has solutions. Recipes are provided from which you can edit the necessary portions for your needs. What this book is not This book does not cover any one topic in extensive detail. If you are interested in conducting analyses or creating plots not covered in the book, I’m sure you’ll find the answer with a quick Google search! 1.1 Why is R so great? R is 100% free and as a result, has a huge support community. Unlike SPSS and even Excel, R is, and always will be completely free. This doesn’t just help your wallet - it means that a huge community of R programmers will constantly develop an distribute new R functionality and packages at a speed that leaves all those other packages in the dust! If you ever have a question about how to implement something in R, a quick Google search will lead you to your answer virtually every single time. R is incredibly versatile. You can use R to do everything from calculating simple summary statistics, to performing complex simulations to creating gorgeous plots. If you can imagine an analytical task, you can almost certainly implement it in R. Analyses conducted in R are transparent, easily shareable, and reproducible. If you ask an SPSS user how they conducted a specific analyses, they will either A) Not remember, B) Try (nervously) to construct an analysis procedure on the spot that makes sense - which may or may not correspond to what they actually did months or years ago, or C) Ask you what you are doing in their house. I used to primarily use SPSS, so I speak from experience on this. If you ask an R user (who uses good programming techniques!) how they conducted an analysis, they should always be able to show you the exact code they used. Of course, this doesn’t mean that they used the appropriate analysis or interpreted it correctly, but with all the original code, any problems should be completely transparent! 1.2 Why R is like a relationship… Yes, R is very much like a relationship. Like relationships, there are two major truths to R programming: Figure 1.1: R will become both your best friend and your worst nightmare. The bad times will make the good times oh so much sweeter. There is nothing more frustrating than when your code does not work There is nothing more satisfying than when your code does work! Anything worth doing, from losing weight to getting a degree, takes time. Learning R is no different. Especially if this is your first experience programming, you are going to experience a lot of headaches when you get started. You will run into error after error and pound your fists against the table screaming: “WHY ISN’T MY CODE WORKING?!?!? There must be something wrong with this stupid software!!!” You will spend hours trying to find a bug in your code, only to find that - frustratingly enough, you had had an extra space or missed a comma somewhere. You’ll then wonder why you ever decided to learn R when (::sigh::) SPSS was so “nice and easy.” Figure 1.2: When you first meet R, it will look so fugly that you’ll wonder if this is all some kind of sick joke. But trust me, once you learn how to talk to it, and clean it up a bit, all your friends will be crazy jealous. Trust me, as you gain more programming experience, you’ll experience fewer and fewer bugs (though they’ll never go away completely). Once you get over the initial barriers, you’ll find yourself conducting analyses much, much faster than you ever did before. 1.3 R resources 1.3.1 R books There are many, many excellent (non-pirate) books on R, some of which are available online for free. Here are some that I highly recommend: Book Description R for Data Science by Garrett Grolemund and Hadley Wickham The best book to learn the latest tools for elegantly doing data science. R Graphics Cookbook by Winston Chang Is indispensible for creating graphics. R Cookbook by James (JD) Long and Paul Teetor Is a useful bag of tips and tricks to get started with R . "],
["get-started.html", "Chapter 2 Getting Started 2.1 Installing Base-R and RStudio 2.2 The four RStudio Windows 2.3 Reading and writing Code 2.4 Debugging 2.5 Learning check", " Chapter 2 Getting Started 2.1 Installing Base-R and RStudio To use R, we’ll need to download two software packages: Base-R, and RStudio. Base-R is the basic software which contains the R programming language. RStudio is software that makes R programming easier. In everyday parlance, R is the engine and RStudio is the car’s frame. Just like you can transfer an engine to different car frames, you can use R using other platforms. But I will use RStudio. Of course, they are totally free and open source. 2.1.1 Check for version updates R and RStudio have been around for several years – however, they are constantly being updated with new features and bug-fixes. At the time that I am writing this sentence (“2020-09-13”), the latest version of Base-R is 4.0.2, and the latest version of RStudio is 1.3.1056 . Figure 2.1: R logo To install Base-R, click on one of the following links and follow the instructions. Operating System Link Windows http://cran.r-project.org/bin/windows/base/ Mac http://cran.r-project.org/bin/macosx/ Once you’ve installed base-R on your computer, try opening it. When you do you should see a screen like the one in Figure 2.2 (this is the Windows version). As you can see, base R is very much bare-bones software. It’s kind of the equivalent of a simple text editor that comes with your computer. Figure 2.2: Here is how the base R application looks. While you can use the base R application alone, most people I know use RStudio – software that helps you to write and use R code more efficiently! Figure 2.3: RStudio logo While you can do pretty much everything you want within base-R, you’ll find that most people these days do their R programming in an application called RStudio. RStudio is a graphical user interface (GUI)-like interface for R that makes programming in R a bit easier. In fact, once you’ve installed RStudio, you’ll likely never need to open the base R application again. To download and install RStudio (around 40mb), go tohttps://rstudio.com/products/rstudio/download/#download/| and follow the instructions. Let’s go ahead and boot up RStudio and see how she looks! 2.2 The four RStudio Windows When you open RStudio, you’ll see the following four windows (also called panes) shown in in Figure 2.4. However, your windows might be in a different order that those in Figure 2.4. Figure 2.4: The four panes of RStudio. Now, let’s see what each window does in detail. 2.2.1 Source - Your notepad for code Figure 2.5: The Source contains all of your individual R scripts. The code won’t be evaluated until you send it to the Console. The source pane is where you create and edit “R Scripts” - your collections of code. Don’t worry, R scripts are just text files with the “.R” extension. When you open RStudio, it will automatically start a new Untitled script. Before you start typing in an untitled R script, you should always save the file under a new file name (like, “StatsAnal.R”). That way, if something on your computer crashes while you’re working, R will have your code waiting for you when you re-open RStudio. You’ll notice that when you’re typing code in a script in the Source panel, R won’t actually evaluate the code as you type. To have R actually evaluate your code, you need to first ‘send’ the code to the Console (we’ll talk about this in the next section). There are many ways to send your code from the Source to the console. The slowest way is to copy and paste. A faster way is to highlight the code you wish to evaluate and clicking on the “Run” button on the top right of the Source. Alternatively, you can use the hot-key “Command + Return” on Mac, or “Control + Enter” on PC to send all highlighted code to the console. 2.2.2 Console: R’s Heart Figure 2.6: The console the calculation heart of R. All of your code will (eventually) go through here. The console is the heart of R. Here is where R actually evaluates code. At the beginning of the console you’ll see the character . This is a prompt that tells you that R is ready for new code. You can type code directly into the console after the prompt and get an immediate response. For example, if you type 1+1 into the console and press enter, you’ll see that R immediately gives an output of 2. 1+1 ## [1] 2 Try calculating 1+1 by typing the code directly into the console - then press Enter. You should see the result [1] 2. Don’t worry about the [1] for now, we’ll get to that later. For now, we’re happy if we just see the 2. Then, type the same code into the Source, and then send the code to the Console by highlighting the code and clicking the ``Run\" button on the top right hand corner of the Source window. Alternatively, you can use the hot-key “Command + Return” on Mac or “Control + Enter” on Windows. Tip: Try to write most of your code in a document in the Source. Only type directly into the Console to do quick calculations like you are using a calculator. So as you can see, you can execute code either by running it from the Source or by typing it directly into the Console. However, 99% most of the time, you should be using the Source rather than the Console. The reason for this is straightforward: If you type code into the console, it won’t be saved (though you can look back on your command History). And if you make a mistake in typing code into the console, you’d have to re-type everything all over again. Instead, it’s better to write all your code in the Source. When you are ready to execute some code, you can then send “Run” it to the console. 2.2.3 Environment / History Figure 2.7: The environment panel shows you all the objects you have defined in your current workspace. The Environment tab of this panel shows you the names of all the data objects (like vectors, matrices, and dataframes) that you’ve defined in your current R session. You can also see information like the number of observations and rows in data objects. The tab also has a few clickable actions like ``Import Dataset\" which will open a graphical user interface (GUI) for important data into R. The History tab of this panel simply shows you a history of all the code you’ve previously evaluated in the Console. As you get more comfortable with R, you might find the Environment / History panel useful. But for now you can just ignore it. If you want to declutter your screen, you can even just minimize the window by clicking the minimize button on the top right of the panel. 2.2.4 Files / Plots / Packages / Help The Files / Plots / Packages / Help panel shows you lots of helpful information. Let’s go through each tab in detail: Files - The files panel gives you access to the file directory on your hard drive. One nice feature of the “Files” panel is that you can use it to set your working directory - once you navigate to a folder you want to read and save files to, click “More” and then “Set As Working Directory.” We’ll talk about working directories in more detail soon. Plots - The Plots panel (no big surprise), shows all your plots. There are buttons for opening the plot in a separate window and exporting the plot as a pdf or jpeg (though you can also do this with code using the pdf() or jpeg() functions.) Let’s see how plots are displayed in the Plots panel. Run the code on the right to display a histogram of the weights of chickens stored in the ChickWeight dataset. When you do, you should see a plot similar to the one in Figure 2.8 show up in the Plots panel. hist(x = ChickWeight$weight, main = &quot;Chicken Weights&quot;, xlab = &quot;Weight&quot;, col = &quot;skyblue&quot;, border = &quot;white&quot;) Figure 2.8: The plot panel contains all of your plots, like this histogram of the distribution of chicken weights. Packages - Shows a list of all the R packages installed on your harddrive and indicates whether or not they are currently loaded. Packages that are loaded in the current session are checked while those that are installed but not yet loaded are unchecked. We’ll discuss packages in more detail in the next section. Help - Help menu for R functions. You can either type the name of a function in the search window, or use the code to search for a function with the name ?hist # How does the histogram function work? ?t.test # What about a t-test? 2.3 Reading and writing Code 2.3.1 Code Chunks In this book, R code is (almost) always presented in a separate gray box like this one: # A code chunk # Define a vector a as the integers from 1 to 5 a &lt;- 1:5 # Print a a ## [1] 1 2 3 4 5 # What is the mean of a? mean(a) ## [1] 3 This is called a code chunk. You should always be able to copy and paste code chunks directly into R. If you copy a chunk and it does not work for you, it is most likely because the code refers to a package, function, or object that I defined in a previous chunk. If so, read back and look for a previous chunk that contains the missing definition. 2.3.2 Comments with # Lines that begin with # are comments. If you evaluate any code that starts with #, R will just ignore that line. In this book, comments will be either be literal comments that I write directly to explain code, or they will be output generated automatically from R. For example, in the code chunk below, you see lines starting with ##. These are the output from the previous line(s) of code. When you run the code yourself, you should see the same output in your console. # This is a comment I wrote 1 + 2 ## [1] 3 # The line above (## [1] 3) is the output from the previous code that has been &#39;commented out&#39; 2.3.3 Element numbers in output [1] The output you see will often start with one or more number(s) in brackets such as [1]. This is just a visual way of telling you where the numbers occur in the output. For example, in the code below, I will print a long vector containing the multiples of 2 from 0 to 100: seq(from = 0, to = 100, by = 2) ## [1] 0 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 ## [20] 38 40 42 44 46 48 50 52 54 56 58 60 62 64 66 68 70 72 74 ## [39] 76 78 80 82 84 86 88 90 92 94 96 98 100 As you can see, the first line of the output starts with ## [1], and the next two lines start with [18] and [35]. This is just telling you that 0 is the [1]st element, 34 is the [18]th element, and 68 is the [35]th element. Sometimes this information will be helpful, but most of the time you can just ignore it. 2.4 Debugging When you are programming, you will always, and I do mean always, make errors (also called bugs) in your code. You might misspell a function, include an extra comma, or some days…R just won’t want to work with you (again, see section Why R is like a Relationship). Debugging will always be a challenge. However, over time you’ll learn which bugs are the most common and get faster and faster at finding and correcting them. Here are the most common bugs you’ll run into as you start your R journey. 2.4.1 R is not ready (&gt;) Another very common problem occurs when R does not seem to be responding to your code. That is, you might run some code like mean(x) expecting some output, but instead, nothing happens. This can be very frustrating because, rather than getting an error, just nothing happens at all. The most common reason for this is because R isn’t ready for new code, instead, it is waiting for you to finish code you started earlier, but never properly finished. Think about it this way, R can be in one of two states: it is either Ready (&gt;) for new code, or it is Waiting (+) for you to finish old code. To see which state R is in, all you have to do is look at the symbol on the console. The &gt; symbol means that R is Ready for new code – this is usually what you want to see. The + symbol means that R is Waiting for you to (properly) finish code you started before. If you see the + symbol, then no matter how much new code you write, R won’t actually evaluate it until you finish the code you started before. Thankfully there is an easy solution to this problem (See Figure 2.9): Just hit the escape key on your keyboard. This will cancel R’s waiting state and make it Ready! Figure 2.9: To turn R from a Waiting (+) state to a Ready (&gt;) state, just hit Escape. 2.4.2 Misspelled object or function If you spell an object or function incorrectly, you’ll receive an error like Error: could not find function or Error: object 'x' not found. In the code below, I’ll try to take the mean of a vector data, but I will misspell the function mean() data &lt;- c(1, 4, 3, 2, 1) # Misspelled function: should be mean(x), not meeen(x) meeen(data) Error: could not find function “meeen” Now, I’ll misspell the object data as dta: # Misspelled object: should be data, not dta mean(dta) Error: object ‘dta’ not found R is case-sensitive, so if you don’t use the correct capitalization you’ll receive an error. In the code below, I’ll use Mean() instead of the correct version mean() # Capitalization is wrong: should be mean(), not Mean() Mean(data) Error: could not find function “Mean” Here is the correct version where both the object data and function mean() are correctly spelled: # Correct: both the object and function are correctly spelled mean(data) ## [1] 2.2 2.4.3 Punctuation problems Another common error is having bad coding “punctuation”. By that, I mean having an extra space, missing a comma, or using a comma (,) instead of a period (.). In the code below, I’ll try to create a vector using periods instead of commas: # Wrong: Using periods (.) instead of commas (,) mean(c(1. 4. 2)) Error: unexpected numeric constant in “mean(c(1. 4.” Because I used periods instead of commas, I get the above error. Here is the correct version # Correct mean(c(1, 4, 2)) ## [1] 2.333333 If you include an extra space in the middle of the name of an object or function, you’ll receive an error. In the code below, I’ll accidentally write Chick Weight instead of ChickWeight: # Wrong: Extra space in the ChickWeight object name head(Chick Weight) Error: unexpected symbol in “head(Chick Weight” Because I had an extra space in the object name, I get the above error. Here is the correction: # Correct: head(ChickWeight) 2.5 Learning check Download R software and RStudio software Open up RStudio software and type the following code below into the console. What does it give you? 1+10 Look at the code below. What will R return after the third line? Make a prediction, then test the code yourself. a &lt;- 10 a + 10 a "],
["basics.html", "Chapter 3 The Basics Download and load libraries 3.1 The command-line (Console) 3.2 Writing R scripts in an editor 3.3 A brief style guide: Commenting and spacing 3.4 Objects and functions", " Chapter 3 The Basics Download and load libraries Libraries are like your iphone apps. The iphone comes with some basic functionality, e.g. weather-app. If you wanted more, you have to download. Subsequent chapters are going to start with this code chunk. This is only needed if you are running one chapter independent from others. Notice how I am using the package called pacman. This is a package manager, which loads any package you typed into it, and if it is not available, download it automatically from CRAN and load it. if (!require(&quot;pacman&quot;)) install.packages(&quot;pacman&quot;) pacman::p_load(tidyverse) # All purpose wrangling for dataframes In this chapter, we’ll go over the basics of the R language and the RStudio programming environment. 3.1 The command-line (Console) Figure 3.1: Yep. R is really just a fancy calculator. R code, on its own, is just text. You can write R code in a new script within R or RStudio, or in any text editor. However, just writing the code won’t do the whole job – in order for your code to be executed (aka, interpreted) you need to send it to the Console. Figure 3.2: You can always type code directly into the command line to get an immediate response. In R, the command-line interpreter starts with the &gt; symbol. This is called the prompt. Why is it called the prompt? Well, it’s “prompting” you to feed it with some R code. The fastest way to have R evaluate code is to type your R code directly into the command-line interpreter. For example, if you type 1+1 into the interpreter and hit enter you’ll see the following 1+1 ## [1] 2 As you can see, R returned the (thankfully correct) value of 2. You’ll notice that the console also returns the text [1]. This is just telling you you the index of the value next to it. Don’t worry about this for now, it will make more sense later. As you can see, R can, thankfully, do basic calculations. In fact, at its heart, R is technically just a fancy calculator. But that’s like saying Michael Jordan is just a fancy ball bouncer or Donald Trump is just an orange with a dead fox on his head. It (and they), are much more than that. 3.2 Writing R scripts in an editor There are certainly many cases where it makes sense to type code directly into the console. For example, to open a help menu for a new function with the ? command, to take a quick look at a dataset with the head() function, or to do simple calculations like 1+1, you should type directly into the console. However, the problem with writing all your code in the console is that nothing that you write will be saved. So if you make an error, or want to make a change to some earlier code, you have to type it all over again. Not very efficient. For this (and many more reasons), you’ll should write any important code that you want to save as an R script. An R script is just a bunch of R code in a single file. You can write an R script in any text editor, but you should save it with the .R suffix to make it clear that it contains R code.} in an editor. In RStudio, you’ll write your R code in the Source window. To start writing a new R script in RStudio, click File – New File – R Script. When you open a new script, you’ll see a blank page waiting for you to write as much R code as you’d like. In Figure 3.3, I have a new script called examplescript with a few random calculations. Figure 3.3: Here’s how a new script looks in the editor window on RStudio. The code you type won’t be executed until you send it to the console. You can have several R scripts open in the source window in separate tabs (like I have above). 3.2.1 Send code from a source to the console Figure 3.4: To evaluate code from the source, highlight it and run it. When you type code into an R script, you’ll notice that, unlike typing code into the Console, nothing happens. In order for R to interpret the code, you need to send it from the Editor to the Console. There are a few ways to do this, but the most common way I use is: Highlight the code you want to run (with your mouse or by holding Shift), then use the Alt+Enter shortcut. 3.3 A brief style guide: Commenting and spacing Like all programming languages, R isn’t just meant to be read by a computer, it’s also meant to be read by other humans. For this reason, it’s important that your code looks nice and is understandable to other people and your future self. To keep things brief, I won’t provide a complete style guide – instead I’ll focus on the two most critical aspects of good style: commenting and spacing. Figure 3.5: As Stan discovered in season six of South Park, your future self is a lazy, possibly intoxicated moron. So do your future self a favor and make your code look nice. Also maybe go for a run once in a while. 3.3.1 Commenting code with the # (pound) sign Comments are completely ignored by R and are just there for whomever is reading the code. You can use comments to explain what a certain line of code is doing, or just to visually separate meaningful chunks of code from each other. Comments in R are designated by a # (pound) sign. Whenever R encounters a # sign, it will ignore all the code after the # sign on that line. Additionally, in most coding editors (like RStudio) the editor will display comments in a separate color than standard R code to remind you that it’s a comment: Here is an example of a short script that is nicely commented. Try to make your scripts look like this! # Author: Pirate Jack # Title: My nicely commented R Script # Date: None today :( # Step 1: Load the yarrr package library(yarrr) # Step 2: See the column names in the movies dataset names(movies) # Step 3: Calculations # What percent of movies are sequels? mean(movies$sequel, na.rm = T) # How much did Pirate&#39;s of the Caribbean: On Stranger Tides make? movies$revenue.all[movies$name == &#39;Pirates of the Caribbean: On Stranger Tides&#39;] I cannot stress enough how important it is to comment your code! Trust me, even if you don’t plan on sharing your code with anyone else, keep in mind that your future self will be reading it in the future. 3.3.2 Spacing Howwouldyouliketoreadabookiftherewerenospacesbetweenwords? I’mguessingyouwouldn’t. Soeverytimeyouwritecodewithoutproperspacing,rememberthissentence. Commenting isn’t the only way to make your code legible. It’s important to make appropriate use of spaces and line breaks. For example, I include spaces between arithmetic operators (like =, + and -) and after commas (which we’ll get to later). For example, look at the following code: Figure 3.6: Don’t make your code look like what a sick Triceratops with diarrhea left behind for Jeff Goldblum. # Shitty looking code a&lt;-(100+3)-2 mean(c(a/100,642564624.34)) t.test(formula=revenue.all~sequel,data=movies) plot(x=movies$budget,y=movies$dvd.usa,main=&quot;myplot&quot;) That code looks like shit. Don’t write code like that. It makes my eyes hurt. Now, let’s use some liberal amounts of commenting and spacing to make it look less shitty. # Some meaningless calculations. Not important a &lt;- (100 + 3) - 2 mean(c(a / 100, 642564624.34)) # t.test comparing revenue of sequels v non-sequels t.test(formula = revenue.all ~ sequel, data = movies) # A scatterplot of budget and dvd revenue. # Hard to see a relationship plot(x = movies$budget, y = movies$dvd.usa, main = &quot;myplot&quot;) See how much better that second chunk of code looks? Not only do the comments tell us the purpose behind the code, but there are spaces and line-breaks separating distinct elements. 3.4 Objects and functions To understand how R works, you need to know that R revolves around two things: objects and functions. Almost everything in R is either an object or a function. In the following code chunk, I’ll define a simple object called tattoos using a function c(): # 1: Create a vector object called tattoos tattoos &lt;- c(4, 67, 23, 4, 10, 35) # 2: Apply the mean() function to the tattoos object mean(tattoos) ## [1] 23.83333 What is an object? An object is a thing – like a number, a dataset, a summary statistic like a mean or standard deviation, or a statistical test. Objects come in many different shapes and sizes in R. There are simple objects like which represent single numbers, vectors (like our tattoos object above) which represent several numbers, more complex objects like dataframes which represent tables of data, and even more complex objects like hypothesis tests or regression which contain all sorts of statistical information. Different types of objects have different attributes. For example, a vector of data has a length attribute (i.e.; how many numbers are in the vector), while a hypothesis test has many attributes such as a test-statistic and a p-value. Don’t worry if this is a bit confusing now – it will all become clearer when you meet these new objects in person in later chapters. For now, just know that objects in R are things, and different objects have different attributes. What is a function? A function is a procedure that typically takes one or more objects as arguments (aka, inputs), does something with those objects, then returns a new object. For example, the mean() function we used above takes a vector object, like tattoos, of numeric data as an argument, calculates the arithmetic mean of those data, then returns a single number (a scalar) as a result.A great thing about R is that you can easily create your own functions that do whatever you want – but we’ll get to that much later in the book. Thankfully, R has hundreds (thousands?) of built-in functions that perform most of the basic analysis tasks you can think of. 99% of the time you are using R, you will do the following: 1) Define objects. 2) Apply functions to those objects. 3) Repeat!. Seriously, that’s about it. However, as you’ll soon learn, the hard part is knowing how to define objects they way you want them, and knowing which function(s) will accomplish the task you want for your objects. 3.4.1 Numbers versus characters For the most part, objects in R come in one of two flavors: numeric and character. It is very important to keep these two separate as certain functions, like mean(), and max() will only work for numeric objects, while functions like grep() and strtrim() only work for character objects. A numeric object is just a number like 1, 10 or 3.14. You don’t have to do anything special to create a numeric object, just type it like you were using a calculator. # These are all numeric objects 1 10 3.14 A character object is a name like \"Madisen\", \"Brian\", or \"University of Konstanz\". To specify a character object, you need to include quotation marks \"\" around the text. # These are all character objects &quot;Madisen&quot; &quot;Brian&quot; &quot;10&quot; If you try to perform a function or operation meant for a numeric object on a character object (and vice-versa), R will yell at you. For example, here’s what happens when I try to take the mean of the two character objects \"1\" and \"10\": # This will return an error because the arguments are not numeric! mean(c(&quot;1&quot;, &quot;10&quot;)) Warning message: argument is not numeric or logical, returning NA If I make sure that the arguments are numeric (by not including the quotation marks), I won’t receive the error: # This is ok! mean(c(1, 10)) ## [1] 5.5 3.4.2 Creating new objects with &lt;- By now you know that you can use R to do simple calculations. But to really take advantage of R, you need to know how to create and manipulate objects. All of the data, analyses, and even plots, you use and create are, or can be, saved as objects in R. To create new objects in R, you need to do object assignment. Object assignment is our way of storing information, such as a number or a statistical test, into something we can easily refer to later. This is a pretty big deal. Object assignment allows us to store data objects under relevant names which we can then use to slice and dice specific data objects anytime we’d like to. To do an assignment, we use the almighty &lt;- operator called assign To assign something to a new object (or to change an existing object), use the notation object &lt;- ...}, where object is the new (or updated) object, and ... is whatever you want to store in object. Let’s start by creating a very simple object called a and assigning the value of 100 to it: Good object names strike a balance between being easy to type (i.e.; short names) and interpret. If you have several datasets, it’s probably not a good idea to name them a, b, c because you’ll forget which is which. However, using long names like March2015Group1OnlyFemales will give you carpal tunnel syndrome. # Create a new object called a with a value of 100 a &lt;- 100 Once you run this code, you’ll notice that R doesn’t tell you anything. However, as long as you didn’t type something wrong, R should now have a new object called a which contains the number 100. If you want to see the value, you need to call the object by just executing its name. This will print the value of the object to the console: # Print the object a a ## [1] 100 Now, R will print the value of a (in this case 100) to the console. If you try to evaluate an object that is not yet defined, R will return an error. For example, let’s try to print the object b which we haven’t yet defined: b Error: object ‘b’ not found As you can see, R yelled at us because the object b hasn’t been defined yet. Once you’ve defined an object, you can combine it with other objects using basic arithmetic. Let’s create objects a and b and play around with them. a &lt;- 1 b &lt;- 100 # What is a + b? a + b ## [1] 101 # Assign a + b to a new object (c) c &lt;- a + b # What is c? c ## [1] 101 3.4.2.1 To change an object, you must assign it again! Normally I try to avoid excessive emphasis, but because this next sentence is so important, I have to just go for it. Here it goes… To change an object, you assign it again! No matter what you do with an object, if you don’t assign it again, it won’t change. For example, let’s say you have an object z with a value of 0. You’d like to add 1 to z in order to make it 1. To do this, you might want to just enter z + 1 – but that won’t do the job. Here’s what happens if you don’t assign it again: z &lt;- 0 z + 1 ## [1] 1 Ok! Now let’s see the value of z z ## [1] 0 Damn! As you can see, the value of z is still 0! What went wrong? Oh yeah… To change an object, you must assign it again! The problem is that when we wrote z + 1 on the second line, R thought we just wanted it to calculate and print the value of z + 1, without storing the result as a new z object. If we want to actually update the value of z, we need to reassign the result back to z as follows: z &lt;- 0 z &lt;- z + 1 # Now I&#39;m REALLY changing z z ## [1] 1 Phew, z is now 1. Because we used assignment, z has been updated. About freaking time. 3.4.3 How to name objects You can create object names using any combination of letters and a few special characters (like . and _). Here are some valid object names # Valid object names group.mean &lt;- 10.21 my.age &lt;- 32 FavoritePirate &lt;- &quot;Jack Sparrow&quot; sum.1.to.5 &lt;- 1 + 2 + 3 + 4 + 5 All the object names above are perfectly valid. Now, let’s look at some examples of invalid object names. These object names are all invalid because they either contain spaces, start with numbers, or have invalid characters: # Invalid object names! famale ages &lt;- 50 # spaces 5experiment &lt;- 50 # starts with a number a! &lt;- 50 # has an invalid character If you try running the code above in R, you will receive a warning message starting with Error: unexpected symbol . Anytime you see this warning in R, it almost always means that you have a naming error of some kind. 3.4.3.1 R is case-sensitive! Figure 3.7: Like a text message, you should probably watch your use of capitalization in R. Like English, R is case-sensitive – it R treats capital letters differently from lower-case letters. For example, the four following objects Plunder, plunder and PLUNDER are totally different objects in R: # These are all different objects Plunder &lt;- 1 plunder &lt;- 100 PLUNDER &lt;- 5 I try to avoid using too many capital letters in object names because they require me to hold the shift key. This may sound silly, but you’d be surprised how much easier it is to type mydata than MyData 100 times. "],
["NavigatingTheSoftware.html", "Chapter 4 Navigating the Software Introduction Download and load libraries 4.1 Getting and Setting the Working Directory 4.2 Creating a new Rstudio project 4.3 Installing Packages 4.4 Learning check", " Chapter 4 Navigating the Software Introduction Both R and RStudio are big chunks of software, first and foremost. You will inevitably spend time doing what one does with any big piece of software: configuring it, customizing it, updating it, and fitting it into your computing environment. This chapter will help you perform those tasks. There is nothing here about numerics, statistics, or graphics. This is all about dealing with R and RStudio as software. Download and load libraries if (!require(&quot;pacman&quot;)) install.packages(&quot;pacman&quot;) pacman::p_load(tidyverse) # All purpose wrangling for dataframes Figure 4.1: Your workspace – all the objects, functions, and delicious glue you’ve defined in your current session. Remember way back in Chapter 3 when I said everything in R is an object? Well, that’s still true. In this chapter, we’ll cover the basics of R object management. We’ll cover how to load new objects like external datasets into R, how to manage the objects that you already have, and how to export objects from R into external files that you can share with other people or store for your own future use. 4.1 Getting and Setting the Working Directory Your computer is a maze of folders, files. Outside of R, when you want to open a specific file, you probably open up an explorer window that allows you to visually search through the folders on your computer. Or, maybe you select recent files, or type the name of the file in a search box to let your computer do the searching for you. While this system usually works for non-programming tasks, it is a no-go for R. Why? Well, the main problem is that all of these methods require you to visually scan your folders and move your mouse to select folders and files that match what you are looking for. When you are programming in R, you need to specify all steps in your analyses in a way that can be easily replicated by others and your future self. This means you can’t just say: “Find this one file I emailed to myself a week ago” or “Look for a file that looks something like experimentAversion3.txt.” Instead, you need to be able to write R code that tells R exactly where to find critical files – either on your computer or on the web. To make this job easier, R uses working directories. A working directory is where everything starts and ends. Your working directory is important because it is the default location for all file input and output—including reading and writing data files, opening and saving script files, and saving your workspace image. Many of you who previously worked with SPSS using the point-click interface, would often wonder 1) where did my saved SPSS file went? or 2) where did my exported image go to? This confusion arise because often you do not know what was the default working directory. Rather than relying on the default, we specify it explicitly so we know where to store our files, and where this software goes looking for files. The easiest and recommended way to set your working directory is using RStudio projects. For every piece of work/assessment, you create a project. The project is a folder that can live anywhere on your computer - your desktop, downloads folder, documents folder, etc. In this folder, it contains everything from your files to be analyzed, codes, and exported files and images. Everything is self-contained, there is no confusion. 4.2 Creating a new Rstudio project You want to create a new RStudio project to keep all your files related to a specific project. Click File → New Project as in Figure 4.2. ** I ALWAYS use this approach, please use it too** Figure 4.2: Selecting New Project This will open the New Project dialog box and allow you to choose which type of project you would like to create, as shown in Figure 4.3. Figure 4.3: New Project dialog Projects are a powerful concept that’s specific to RStudio. They help you by doing the following: Setting your working directory to the project directory. Preserving window state in RStudio so when you return to a project your windows are all as you left them. This includes opening any files you had open when you last saved your project. Preserving RStudio project settings. To hold your project settings, RStudio creates a project file with an .Rproj extension in the project directory. If you open the project file in RStudio, it works like a shortcut for opening the project. In addition, RStudio creates a hidden directory named .Rproj.user to house temporary files related to your project. Any time you’re working on something nontrivial in R we recommend creating an RStudio project. Projects help you stay organized and make your project workflow easier. 4.3 Installing Packages When you download and install R for the first time, you are installing the Base R software. Base R will contain most of the functions you’ll use on a daily basis like mean() and hist(). However, only functions written by the original authors of the R language will appear here. If you want to access data and code written by other people, you’ll need to install it as a package. An R package is simply a bunch of data, from functions, to help menus, to vignettes (examples), stored in one neat package. Figure 4.4: An R package is like a lightbulb. First you need to order it with install.packages(). Then, every time you want to use it, you need to turn it on with library() A package is like a light bulb. In order to use it, you first need to order it to your house (i.e.; your computer) by installing it. Once you’ve installed a package, you never need to install it again. However, every time you want to actually use the package, you need to turn it on by loading it. Here’s how to do it. 4.3.1 Installing a new package Installing a package simply means downloading the package code onto your personal computer. There are two main ways to install new packages. The first, and most common, method is to download them from the Comprehensive R Archive Network (CRAN). CRAN is the central repository for R packages. To install a new R package from CRAN, you can simply run the code install.packages(\"name\"), where “name” is the name of the package. For example, to download the tidyverse package, which contains several functions we will use in this book, you should run the following: Figure 4.5: CRAN (Comprehensive R Archive Network) is the main source of R packages # Install the tidyverse package from CRAN # You only need to install a package once! install.packages(&quot;tidyverse&quot;) When you run install.packages(\"name\") R will download the package from CRAN. If everything works, you should see some information about where the package is being downloaded from, in addition to a progress bar. Figure 4.6: When you install a new package, you’ll see some random text like this you the download progress. You don’t need to memorize this. Like ordering a light bulb, once you’ve installed a package on your computer you never need to install it again (unless you want to try to install a new version of the package). However, every time you want to use it, you need to turn it on by loading it. 4.3.2 Loading a package Once you’ve installed a package, it’s on your computer. However, just because it’s on your computer doesn’t mean R is ready to use it. If you want to use something, like a function or dataset, from a package you always need to load the package in your R session first. Just like a light bulb, you need to turn it on to use it! To load a package, you use the library() function. For example, now that we’ve installed the tidyverse package, we can load it with library(\"tidyverse\"): # Load the tidyverse package so I can use it! # You have to load a package in every new R session! library(&quot;tidyverse&quot;) Now that you’ve loaded the tidyverse package, you can use any of its functions! Let us create a very simple histogram plot using a default dataset found within R. Don’t worry about the specifics of the code below, you’ll learn more about how all this works later. For now, just run the code and marvel at your plot in TWO LINES. # Make a pirateplot using the pirateplot() function # from the yarrr package! ggplot(mtcars,aes(x=mpg)) + geom_histogram(binwidth=5) 4.3.3 A simple approach to package For novices, the pacman package can be used. All you need to do is to type in the name of the package in the function pacman::p_load(). In the example below, I want pacman to load the package tidverse – notice how \"\" are not used. If tidverse is not found in your computer, pacman will download it first, than automatically load it. I will use this command from now on when loading packages. if (!require(&quot;pacman&quot;)) install.packages(&quot;pacman&quot;) pacman::p_load(tidyverse) # All purpose wrangling for dataframes 4.4 Learning check Create a folder called se201 on your computer desktop. Create a new project inside the folder se201, click File – New Project – New Directory – New Project – Browse, search for se201 folder – under Directory name, type practice. Create a new R script, click File – New File – R Script. Save the new R script, click File – Save As. Use the file name practice_script. It will have the extension .R assigned to it automatically Enter the code below into your new script, and save it. # This is my first lines of codes a &lt;- 10 a + 10 a Close RStudio, reopen RStudio via the .Rproj symbol. In the Files tab on the bottom right, you should see the script you created practice_script.R. Click on it to open and you should see the code you typed. Try to run the codes you typed, what answer did you get? "],
["InputOuput.html", "Chapter 5 Input and Output Download and load libraries 5.1 Dealing with “Cannot Open File” in Windows 5.2 Reading in Excel “.xlsx” data 5.3 Writing a Data Frame to Excel 5.4 Learning check", " Chapter 5 Input and Output Download and load libraries if (!require(&quot;pacman&quot;)) install.packages(&quot;pacman&quot;) pacman::p_load(tidyverse, # All purpose wrangling for dataframes openxlsx) # writing excel documents 5.1 Dealing with “Cannot Open File” in Windows You are running R on Windows, and you are using filenames such as C:\\data\\sample.xlsx. R says it cannot open the file, but you know the file does exist. The backslashes in the filepath are causing trouble. You can solve this problem in one of two ways: Change the backslashes, \\, to forward, /, slashes: \"C:/data/sample.txt\". Double the backslashes: \"C:\\\\data\\\\sample.txt\". When you open a file in R, you give the filename as a character string. Problems arise when the name contains backslashes (\\) because backslashes have a special meaning inside strings. You’ll probably get something like this: samp &lt;- read.xlsx (&quot;data\\STRENGTH.xlsx&quot;) ## Error: &#39;\\S&#39; is an unrecognized escape in character string starting &quot;&quot;data\\S&quot; R escapes every character that follows a backslash and then removes the backslashes. That leaves a meaningless filepath, such as C:Datasample-data.csv in this example. The simple solution is to use forward slashes instead of backslashes. R leaves the forward slashes alone, and Windows treats them just like backslashes. Problem solved: samp &lt;- read.xlsx (&quot;data/STRENGTH.xlsx&quot;) An alternative solution is to double the backslashes, since R replaces two consecutive backslashes with a single backslash: samp &lt;- read.xlsx (&quot;data\\\\STRENGTH.xlsx&quot;) 5.2 Reading in Excel “.xlsx” data If you have a .xlsx file that you want to read into R, use the read.xlsx() function in the openxlsx package. Argument Description xlsxFile The document’s file path relative to the working directory unless specified otherwise. For example xlsxFile = \"SubjectData.xlsx\" looks for the text file directly in the working directory, while xlsxFile = \"data/SubjectData.xlsx\" will look for the file in an existing folder called data inside the working directory.If the file is outside of your working directory, you can also specify a full file path (xlsxFile = \"C:/Users/bl19622/Box/myBox/Documents/teaching/se747_ResearchMeth/sample_book/data/SubjectData.xlsx\"). sheet The name of the excel sheet or the numerical index. This is useful if you have many sheets in one Excel workbook. If this is not specified, the function automatically reads in the first sheet in the Excel workbook. Let’s test this function out by reading in an Excel file titled strength.xlsx. Since the file is located in a folder called data in my working directory, I’ll use the file path xlsxFile = \"strength.xlsx\", and since the sheet I have is named \"data\", I will use sheet = \"data\": strn &lt;- read.xlsx (xlsxFile = &quot;data/STRENGTH.xlsx&quot;, sheet = &quot;data&quot;) 5.3 Writing a Data Frame to Excel You want to write an R data frame to an Excel file. Argument Description x The object you are trying to export and write into an Excel file, commonly a dataframe you modified. For example x = strn. sheetName If you want to name the sheet of the Excel workbook. file Specifying where you want to export the Excel sheet relative to the working directory, and how you want to name the sheet you exported. write.xlsx(x = strn, sheetName = &quot;strength&quot;, file = &quot;data/STRENGTH_write.xlsx&quot;) 5.4 Learning check From your learning check in 4.4, open RStudio via the .Rproj symbol. In the Files tab on the bottom right, you should see the script you created practice_script.R. Click on it to open. Import the Excel file data/treadmill_pt4.xlsx, and the sheet named raw and assign it to an object dat. See Recipe 5.2. Remember to add some comments to remind yourself what this line of code is trying to do. Save it. "],
["WRANGLE.html", "Chapter 6 Data manipulation Download and load libraries Import data 6.1 Renaming variables 6.2 Subset rows 6.3 Convert characters to numeric 6.4 Convert characters to date and time 6.5 Split Numeric Variable into Categories 6.6 Tidy data 6.7 Spreading 6.8 Gathering 6.9 Rename values of a variable 6.10 Creating factors 6.11 Making a new variable 6.12 Filtering 6.13 Global summary 6.14 Group-by summary 6.15 Merge two tables together 6.16 Learning check", " Chapter 6 Data manipulation Download and load libraries if (!require(&quot;pacman&quot;)) install.packages(&quot;pacman&quot;) pacman::p_load(tidyverse, # All purpose wrangling for dataframes openxlsx,# writing excel documents lubridate,# date-time tibbletime) # moving average for vo2 Import data Let’s load the 3 files from data folder into the workspace again. File one contains the FMS data, another the VO2 raw data from the treadmill test, and lastly the lactate data from the treadmill test. dat_fms &lt;- read.xlsx (xlsxFile = &quot;data/fms_pt3.xlsx&quot;, sheet = &quot;Sheet1&quot;) dat_vo2 &lt;- read.xlsx (xlsxFile = &quot;data/treadmill_pt4.xlsx&quot;, sheet = &quot;raw&quot;) dat_vo2_stage &lt;- read.xlsx (xlsxFile = &quot;data/treadmill_pt4.xlsx&quot;, sheet = &quot;stage&quot;) 6.1 Renaming variables 6.1.1 Problem The current column names in the dat_vo2 dataset is ugly, and you like to abbreviate it. I dislike excessively using capitals in naming stuff. It is alot of effort to type. 6.1.2 Solution Create a vector of 8 new names that you can give to the data. The order of new names must be identical to the order of the old names from left to right. # This prints the current column names colnames (dat_vo2) ## [1] &quot;Time&quot; &quot;BF&quot; &quot;VO2/kg&quot; &quot;RER&quot; &quot;V&#39;O2&quot; &quot;V&#39;CO2&quot; &quot;V&#39;E&quot; &quot;HR&quot; # New names. Notice the commas and be pedantic about spacing new_names &lt;- c(&quot;time&quot;, &quot;bf&quot;, &quot;vo2_norm&quot;, &quot;rer&quot;, &quot;vo2&quot;, &quot;vco2&quot;, &quot;ve&quot;, &quot;hr&quot;) # Give the new names to the old names colnames (dat_vo2) &lt;- new_names # This prints the new column names colnames (dat_vo2) ## [1] &quot;time&quot; &quot;bf&quot; &quot;vo2_norm&quot; &quot;rer&quot; &quot;vo2&quot; &quot;vco2&quot; &quot;ve&quot; ## [8] &quot;hr&quot; 6.2 Subset rows 6.2.1 Problem You want to remove a specific row or a range of rows, and remove a specific column or a range of columns. See also Recipe 6.12. 6.2.2 Solution To keep or remove rows based on the row numbers, use slice (). In slice, when you want to keep the row, add that row number. If you want to remove that row number, use a minus sign, -, before the number. If you want to keep or remove a range of numbers, use (start:end). To keep keeps based on the column names, use the select () function. # This keeps only the second row dat_vo2 %&gt;% slice (2) %&gt;% head() ## time bf vo2_norm rer vo2 vco2 ve hr ## 1 min/kg &lt;NA&gt; # This removes the second row dat_vo2 %&gt;% slice (-2)%&gt;% head() ## time bf vo2_norm rer vo2 vco2 ve hr ## 1 min 1/min ml/ ml/min ml/min L/min bpm ## 2 00:05 37 21.4 0.93 1371 1272 46 119 ## 3 00:10 58 2.5 0.84 159 133 12 120 ## 4 00:15 30 23.5 0.74 1506 1110 35 121 ## 5 00:20 34 22.4 0.86 1437 1229 43 123 ## 6 00:25 23 15.6 0.73 1004 735 22 124 # This removes the second and third rows dat_vo2 %&gt;% slice (-(2:3))%&gt;% head() ## time bf vo2_norm rer vo2 vco2 ve hr ## 1 min 1/min ml/ ml/min ml/min L/min bpm ## 2 00:10 58 2.5 0.84 159 133 12 120 ## 3 00:15 30 23.5 0.74 1506 1110 35 121 ## 4 00:20 34 22.4 0.86 1437 1229 43 123 ## 5 00:25 23 15.6 0.73 1004 735 22 124 ## 6 00:30 27 30.5 0.76 1960 1489 48 124 # This removes the second column dat_vo2 %&gt;% select (time, bf, rer) %&gt;% head() ## time bf rer ## 1 min 1/min ## 2 ## 3 00:05 37 0.93 ## 4 00:10 58 0.84 ## 5 00:15 30 0.74 ## 6 00:20 34 0.86 # This removes the first and second row, and replaces the old data in object dat_vo2 dat_vo2 &lt;- dat_vo2 %&gt;% slice (-(1:2)) 6.3 Convert characters to numeric 6.3.1 Problem The raw Vo2 treadmill dataset contains predominantly numbers, meaning it is numeric in nature. But let us see the type of data that was imported. The str() function provides us with some summary information about the dataframe. str(dat_vo2) ## &#39;data.frame&#39;: 330 obs. of 8 variables: ## $ time : chr &quot; 00:05 &quot; &quot; 00:10 &quot; &quot; 00:15 &quot; &quot; 00:20 &quot; ... ## $ bf : chr &quot;37&quot; &quot;58&quot; &quot;30&quot; &quot;34&quot; ... ## $ vo2_norm: chr &quot;21.4&quot; &quot;2.5&quot; &quot;23.5&quot; &quot;22.4&quot; ... ## $ rer : chr &quot;0.93&quot; &quot;0.84&quot; &quot;0.74&quot; &quot;0.86&quot; ... ## $ vo2 : chr &quot;1371&quot; &quot;159&quot; &quot;1506&quot; &quot;1437&quot; ... ## $ vco2 : chr &quot;1272&quot; &quot;133&quot; &quot;1110&quot; &quot;1229&quot; ... ## $ ve : chr &quot;46&quot; &quot;12&quot; &quot;35&quot; &quot;43&quot; ... ## $ hr : chr &quot;119&quot; &quot;120&quot; &quot;121&quot; &quot;123&quot; ... What you will see is something like this. For the variable bf, you will see $ bf : chr \"37\" \"58\" \"30\" \"34\" .... chr after the colon indicates that this variable is a character (chr). In R language, a character is anything from a letter, e.g. a, to a word, e.g. word, to even a phrase of sentence, e.g. i hate biomechanics. A character is always enclosed inside a \"\". Why is R so “stupid”, that it cannot differentiate numbers from words!! Well it is not that R is stupid, but it is that in our original data, characters were mixed with numbers (Figure @ref(fig:vo2-col_class)). This will be expanded upon in the Recipe 6.6, about why this is bad data formatting. In brief, each column should be made up of one type of data. If it is numbers, make it all numbers; characters, all characters. If you have mix, the default is that R treats that column as all characters. The reason why you should not leave numbers as characters is that you cannot do math on it. You cannot add apples and orange can you? (#fig:vo2-col_class)The type of data for each class as it was imported. 6.3.2 Solution Use the mutate() function and the as.numeric function. dat_vo2 &lt;- dat_vo2 %&gt;% mutate (bf = as.numeric(bf), vo2_norm = as.numeric(vo2_norm), rer = as.numeric(rer), vo2 = as.numeric(vo2), vco2 = as.numeric(vco2), ve = as.numeric(ve), hr = as.numeric(hr)) # Recheck the type of each column str(dat_vo2) ## &#39;data.frame&#39;: 330 obs. of 8 variables: ## $ time : chr &quot; 00:05 &quot; &quot; 00:10 &quot; &quot; 00:15 &quot; &quot; 00:20 &quot; ... ## $ bf : num 37 58 30 34 23 27 39 34 26 27 ... ## $ vo2_norm: num 21.4 2.5 23.5 22.4 15.6 30.5 23.3 29.6 31.9 29.4 ... ## $ rer : num 0.93 0.84 0.74 0.86 0.73 0.76 0.73 0.75 0.8 0.8 ... ## $ vo2 : num 1371 159 1506 1437 1004 ... ## $ vco2 : num 1272 133 1110 1229 735 ... ## $ ve : num 46 12 35 43 22 48 38 49 53 49 ... ## $ hr : num 119 120 121 123 124 124 124 124 124 125 ... 6.4 Convert characters to date and time 6.4.1 Problem The raw dat_vo2 data time variable is a character with ugly white spaces. When you use the str() function on the time column using the $ symbol, you can see that each value looks like \" 00:05 \". It means that is a blank before and after the 00:05. str(dat_vo2$time) ## chr [1:330] &quot; 00:05 &quot; &quot; 00:10 &quot; &quot; 00:15 &quot; &quot; 00:20 &quot; &quot; 00:25 &quot; ... 6.4.2 Solution Use the mutate() function and the as.numeric function. You will learn the mutate () function more in Recipe (WRANGLE-NEW-VARIABLES). dat_vo2 &lt;- dat_vo2 %&gt;% mutate (time = time %&gt;% str_squish() %&gt;% # function strips any whitespaces ms() %&gt;% # convert to minutes and seconds as.period(unit = &quot;sec&quot;) %&gt;% # converts entirely to seconds as.numeric ()) # strips the S symbol to make it a number # Recheck the type of each column str(dat_vo2) ## &#39;data.frame&#39;: 330 obs. of 8 variables: ## $ time : num 5 10 15 20 25 30 35 40 45 50 ... ## $ bf : num 37 58 30 34 23 27 39 34 26 27 ... ## $ vo2_norm: num 21.4 2.5 23.5 22.4 15.6 30.5 23.3 29.6 31.9 29.4 ... ## $ rer : num 0.93 0.84 0.74 0.86 0.73 0.76 0.73 0.75 0.8 0.8 ... ## $ vo2 : num 1371 159 1506 1437 1004 ... ## $ vco2 : num 1272 133 1110 1229 735 ... ## $ ve : num 46 12 35 43 22 48 38 49 53 49 ... ## $ hr : num 119 120 121 123 124 124 124 124 124 125 ... 6.4.3 Discussion Notice in the function above, I chained a series of steps together, using the pipe, %&gt;%, function. Alternatively, I could do it in separate steps, and we can take a look at how each step changed the appearance of the time variable. # removes whitespaces around the time variable dat_vo2 %&gt;% mutate (time = time %&gt;% str_squish()) %&gt;% head() ## time bf vo2_norm rer vo2 vco2 ve hr ## 1 5 37 21.4 0.93 1371 1272 46 119 ## 2 10 58 2.5 0.84 159 133 12 120 ## 3 15 30 23.5 0.74 1506 1110 35 121 ## 4 20 34 22.4 0.86 1437 1229 43 123 ## 5 25 23 15.6 0.73 1004 735 22 124 ## 6 30 27 30.5 0.76 1960 1489 48 124 # convert to minutes and seconds dat_vo2 %&gt;% mutate (time = time %&gt;% ms())%&gt;% head() ## Warning: Problem with `mutate()` input `time`. ## x Some strings failed to parse, or all strings are NAs ## i Input `time` is `time %&gt;% ms()`. ## Warning in .parse_hms(..., order = &quot;MS&quot;, quiet = quiet): Some strings failed to ## parse, or all strings are NAs ## time bf vo2_norm rer vo2 vco2 ve hr ## 1 &lt;NA&gt; 37 21.4 0.93 1371 1272 46 119 ## 2 &lt;NA&gt; 58 2.5 0.84 159 133 12 120 ## 3 &lt;NA&gt; 30 23.5 0.74 1506 1110 35 121 ## 4 &lt;NA&gt; 34 22.4 0.86 1437 1229 43 123 ## 5 &lt;NA&gt; 23 15.6 0.73 1004 735 22 124 ## 6 &lt;NA&gt; 27 30.5 0.76 1960 1489 48 124 # converts entirely to seconds dat_vo2 %&gt;% mutate (time = time %&gt;% as.period(unit = &quot;sec&quot;))%&gt;% head() ## time bf vo2_norm rer vo2 vco2 ve hr ## 1 5S 37 21.4 0.93 1371 1272 46 119 ## 2 10S 58 2.5 0.84 159 133 12 120 ## 3 15S 30 23.5 0.74 1506 1110 35 121 ## 4 20S 34 22.4 0.86 1437 1229 43 123 ## 5 25S 23 15.6 0.73 1004 735 22 124 ## 6 30S 27 30.5 0.76 1960 1489 48 124 # strips the S symbol to make it a number dat_vo2 %&gt;% mutate (time = time %&gt;% as.numeric ())%&gt;% head() ## time bf vo2_norm rer vo2 vco2 ve hr ## 1 5 37 21.4 0.93 1371 1272 46 119 ## 2 10 58 2.5 0.84 159 133 12 120 ## 3 15 30 23.5 0.74 1506 1110 35 121 ## 4 20 34 22.4 0.86 1437 1229 43 123 ## 5 25 23 15.6 0.73 1004 735 22 124 ## 6 30 27 30.5 0.76 1960 1489 48 124 6.5 Split Numeric Variable into Categories 6.5.1 Problem You want to split the time variable of the dat_vo2 dataset into chunks of 210 sec, and create a new variable called stage. You will learn the mutate () function more in Recipe 6.11. I will not the cut_interval function explain, other than to say the length argument is used to specify the range of evenly spaced values to categorize over. 6.5.2 Solution dat_vo2 &lt;- dat_vo2 %&gt;% mutate (stage = cut_interval(time, length = 210, labels = FALSE)) dat_vo2 ## time bf vo2_norm rer vo2 vco2 ve hr stage ## 1 5 37 21.40000 0.930000 1371 1272 46 119 1 ## 2 10 58 2.50000 0.840000 159 133 12 120 1 ## 3 15 30 23.50000 0.740000 1506 1110 35 121 1 ## 4 20 34 22.40000 0.860000 1437 1229 43 123 1 ## 5 25 23 15.60000 0.730000 1004 735 22 124 1 ## 6 30 27 30.50000 0.760000 1960 1489 48 124 1 ## 7 35 39 23.30000 0.730000 1499 1092 38 124 1 ## 8 40 34 29.60000 0.750000 1902 1427 49 124 1 ## 9 45 26 31.90000 0.800000 2048 1641 53 124 1 ## 10 50 27 29.40000 0.800000 1891 1519 49 125 1 ## 11 55 34 28.90000 0.790000 1856 1465 47 126 1 ## 12 60 32 29.90000 0.800000 1919 1526 49 126 1 ## 13 65 31 29.90000 0.790000 1922 1513 46 124 1 ## 14 70 24 33.00000 0.840000 2118 1779 56 126 1 ## 15 75 42 29.90000 0.800000 1921 1543 50 126 1 ## 16 80 33 31.70000 0.800000 2035 1638 51 124 1 ## 17 85 24 32.10000 0.820000 2060 1692 50 125 1 ## 18 90 28 32.90000 0.820000 2112 1731 53 126 1 ## 19 95 28 33.70000 0.830000 2164 1795 52 130 1 ## 20 100 24 33.40000 0.870000 2142 1863 57 128 1 ## 21 105 31 31.10000 0.850000 1997 1694 52 129 1 ## 22 110 21 34.50000 0.880000 2214 1945 58 130 1 ## 23 115 37 32.70000 0.840000 2098 1761 55 131 1 ## 24 120 28 34.70000 0.850000 2230 1905 58 131 1 ## 25 125 33 34.30000 0.870000 2201 1904 61 132 1 ## 26 130 30 28.30000 0.870000 1814 1579 51 133 1 ## 27 135 29 32.60000 0.890000 2094 1861 57 133 1 ## 28 140 32 35.40000 0.860000 2275 1961 60 133 1 ## 29 145 30 33.50000 0.880000 2149 1889 58 133 1 ## 30 150 28 33.90000 0.900000 2176 1962 60 134 1 ## 31 155 24 33.70000 0.930000 2166 2013 63 134 1 ## 32 160 34 17.50000 0.880000 1124 993 34 135 1 ## 33 165 25 36.30000 0.790000 2332 1844 48 136 1 ## 34 170 33 38.00000 0.840000 2439 2053 65 137 1 ## 35 175 34 33.90000 0.870000 2179 1896 61 138 1 ## 36 180 34 32.40000 0.900000 2077 1868 60 139 1 ## 37 185 46 32.20000 0.860000 2069 1773 61 140 1 ## 38 190 26 25.30000 1.000000 1625 1623 63 141 1 ## 39 195 27 17.00000 1.090000 1094 1198 49 145 1 ## 40 200 27 15.20000 1.150000 977 1122 47 148 1 ## 41 205 27 15.80000 1.180000 1017 1196 49 151 1 ## 42 210 24 12.10000 1.130000 779 879 36 154 1 ## 43 215 51 18.30000 0.960000 1175 1130 45 156 2 ## 44 220 40 35.80000 0.820000 2299 1892 57 149 2 ## 45 225 57 29.30000 0.770000 1883 1442 50 138 2 ## 46 230 33 33.00000 0.880000 2118 1869 62 131 2 ## 47 235 35 26.90000 0.940000 1727 1620 55 130 2 ## 48 240 46 27.70000 0.810000 1776 1444 49 132 2 ## 49 245 35 35.00000 0.840000 2245 1888 63 132 2 ## 50 250 43 29.70000 0.840000 1906 1595 54 133 2 ## 51 255 27 30.50000 0.840000 1961 1643 52 137 2 ## 52 260 23 31.30000 0.800000 2012 1612 48 139 2 ## 53 265 29 35.90000 0.810000 2306 1871 57 140 2 ## 54 270 31 34.00000 0.820000 2181 1790 55 139 2 ## 55 275 34 31.40000 0.830000 2018 1666 52 137 2 ## 56 280 34 36.80000 0.850000 2363 1997 63 140 2 ## 57 285 34 34.90000 0.840000 2240 1889 59 142 2 ## 58 290 24 36.00000 0.890000 2314 2059 62 144 2 ## 59 295 28 31.30000 0.830000 2007 1667 47 145 2 ## 60 300 40 36.70000 0.800000 2354 1888 57 146 2 ## 61 305 30 36.90000 0.870000 2369 2053 62 145 2 ## 62 310 37 25.00000 0.830000 1603 1338 41 145 2 ## 63 315 32 37.40000 0.870000 2399 2083 63 144 2 ## 64 320 29 36.40000 0.890000 2338 2081 64 145 2 ## 65 325 35 34.20000 0.860000 2193 1880 58 144 2 ## 66 330 32 26.40000 0.890000 1696 1507 48 146 2 ## 67 335 17 40.00000 0.820000 2571 2101 51 147 2 ## 68 340 26 38.80000 0.820000 2491 2033 55 147 2 ## 69 345 21 33.70000 0.840000 2163 1817 48 147 2 ## 70 350 29 36.70000 0.840000 2356 1991 57 147 2 ## 71 355 33 31.20000 0.850000 2005 1707 51 146 2 ## 72 360 38 39.40000 0.840000 2530 2114 63 145 2 ## 73 365 30 35.60000 0.880000 2288 2009 60 145 2 ## 74 370 27 33.30000 0.890000 2135 1907 55 145 2 ## 75 375 40 36.50000 0.870000 2344 2043 64 146 2 ## 76 380 31 26.00000 0.890000 1672 1487 45 147 2 ## 77 385 43 41.40000 0.860000 2661 2285 69 149 2 ## 78 390 37 34.80000 0.900000 2233 2014 63 150 2 ## 79 395 47 32.10000 0.910000 2063 1879 65 150 2 ## 80 400 28 27.90000 1.050000 1791 1872 71 150 2 ## 81 405 32 16.00000 1.150000 1027 1180 52 156 2 ## 82 410 30 16.40000 1.270000 1051 1334 60 159 2 ## 83 415 32 10.30000 1.200000 662 795 38 163 2 ## 84 420 26 17.50000 1.130000 1125 1266 47 164 2 ## 85 425 47 21.80000 0.930000 1403 1301 46 166 3 ## 86 430 35 37.40000 0.890000 2404 2138 65 158 3 ## 87 435 42 31.70000 0.900000 2037 1826 60 149 3 ## 88 440 33 29.80000 0.930000 1912 1781 55 141 3 ## 89 445 23 32.00000 0.920000 2054 1890 57 141 3 ## 90 450 41 30.40000 0.850000 1955 1662 53 144 3 ## 91 455 44 32.40000 0.830000 2081 1727 57 145 3 ## 92 460 37 34.10000 0.840000 2192 1833 58 145 3 ## 93 465 25 34.00000 0.890000 2183 1940 59 145 3 ## 94 470 29 34.20000 0.850000 2198 1866 56 148 3 ## 95 475 36 36.40000 0.830000 2336 1949 60 148 3 ## 96 480 35 35.90000 0.860000 2303 1978 61 149 3 ## 97 485 34 38.50000 0.890000 2471 2194 68 150 3 ## 98 490 36 34.70000 0.870000 2229 1949 60 151 3 ## 99 495 28 36.50000 0.870000 2346 2053 60 154 3 ## 100 500 32 37.10000 0.880000 2382 2085 62 153 3 ## 101 505 29 38.20000 0.880000 2452 2163 63 153 3 ## 102 510 27 35.00000 0.860000 2246 1924 54 154 3 ## 103 515 30 39.10000 0.880000 2513 2216 65 154 3 ## 104 520 25 37.10000 0.920000 2380 2178 64 154 3 ## 105 525 39 38.10000 0.890000 2444 2171 67 155 3 ## 106 530 33 38.10000 0.920000 2448 2248 68 157 3 ## 107 535 30 37.90000 0.900000 2436 2198 63 159 3 ## 108 540 34 37.80000 0.900000 2426 2191 65 159 3 ## 109 545 38 38.20000 0.890000 2455 2195 67 158 3 ## 110 550 33 38.70000 0.920000 2482 2276 68 159 3 ## 111 555 33 38.10000 0.930000 2448 2288 70 159 3 ## 112 560 32 38.00000 0.940000 2441 2298 70 161 3 ## 113 565 32 38.90000 0.920000 2496 2302 69 161 3 ## 114 570 28 37.80000 0.940000 2427 2271 68 162 3 ## 115 575 27 36.70000 0.900000 2356 2120 60 162 3 ## 116 580 35 31.70000 0.890000 2033 1801 53 162 3 ## 117 585 35 40.30000 0.900000 2587 2323 70 162 3 ## 118 590 39 40.00000 0.910000 2571 2336 73 161 3 ## 119 595 38 38.00000 0.930000 2439 2279 73 160 3 ## 120 600 34 37.80000 0.940000 2425 2289 71 161 3 ## 121 605 48 32.40000 0.900000 2079 1879 65 162 3 ## 122 610 34 26.70000 1.020000 1716 1752 68 163 3 ## 123 615 31 17.00000 1.200000 1094 1317 62 165 3 ## 124 620 34 17.30000 1.270000 1111 1417 66 169 3 ## 125 625 39 17.00000 1.200000 1092 1306 58 174 3 ## 126 630 52 14.50000 1.070000 929 998 46 176 3 ## 127 635 48 22.20000 0.950000 1425 1356 51 177 4 ## 128 640 50 41.10000 0.840000 2636 2225 67 174 4 ## 129 645 38 38.30000 0.890000 2461 2190 68 165 4 ## 130 650 46 33.40000 0.920000 2146 1971 66 156 4 ## 131 655 36 31.70000 0.940000 2036 1911 62 154 4 ## 132 660 31 38.00000 0.910000 2441 2210 70 156 4 ## 133 665 34 34.80000 0.890000 2236 1996 66 158 4 ## 134 670 38 34.30000 0.870000 2202 1921 62 158 4 ## 135 675 35 38.80000 0.850000 2488 2110 65 159 4 ## 136 680 30 38.00000 0.890000 2437 2179 69 160 4 ## 137 685 28 34.90000 0.870000 2238 1936 55 160 4 ## 138 690 25 36.30000 0.840000 2332 1965 56 162 4 ## 139 695 39 38.40000 0.830000 2468 2044 62 163 4 ## 140 700 35 40.50000 0.880000 2602 2284 71 163 4 ## 141 705 30 38.90000 0.920000 2497 2286 69 164 4 ## 142 710 38 37.20000 0.890000 2387 2131 65 164 4 ## 143 715 31 38.50000 0.900000 2473 2234 66 166 4 ## 144 720 30 39.00000 0.910000 2502 2272 66 166 4 ## 145 725 32 38.00000 0.910000 2440 2227 66 166 4 ## 146 730 26 37.40000 0.910000 2403 2189 62 167 4 ## 147 735 29 37.70000 0.900000 2418 2170 62 168 4 ## 148 740 31 37.80000 0.920000 2424 2230 65 169 4 ## 149 745 35 38.90000 0.900000 2496 2242 66 168 4 ## 150 750 35 38.20000 0.920000 2450 2261 67 168 4 ## 151 755 48 39.80000 0.920000 2554 2351 74 168 4 ## 152 760 40 37.80000 0.950000 2428 2316 72 168 4 ## 153 765 36 38.10000 0.960000 2447 2344 72 169 4 ## 154 770 39 38.70000 0.950000 2484 2353 71 170 4 ## 155 775 35 39.00000 0.960000 2502 2391 73 171 4 ## 156 780 41 39.90000 0.970000 2564 2486 78 171 4 ## 157 785 42 37.20000 0.970000 2389 2321 74 171 4 ## 158 790 42 37.10000 0.960000 2381 2288 72 172 4 ## 159 795 40 40.00000 0.970000 2569 2504 80 172 4 ## 160 800 33 35.90000 0.930000 2304 2147 61 172 4 ## 161 805 37 38.90000 0.930000 2498 2332 71 173 4 ## 162 810 34 37.90000 0.940000 2433 2283 69 173 4 ## 163 815 42 34.70000 0.950000 2231 2109 70 173 4 ## 164 820 35 23.00000 1.110000 1476 1634 70 173 4 ## 165 825 34 16.40000 1.280000 1056 1348 64 175 4 ## 166 830 30 15.30000 1.300000 985 1282 56 178 4 ## 167 835 36 17.50000 1.190000 1122 1341 54 180 4 ## 168 840 39 19.70000 1.160000 1263 1464 59 181 4 ## 169 845 59 25.40000 1.030000 1628 1669 63 181 5 ## 170 850 49 39.80000 0.900000 2554 2302 69 177 5 ## 171 855 41 35.20000 0.950000 2258 2147 68 171 5 ## 172 860 43 32.70000 1.000000 2099 2109 70 165 5 ## 173 865 40 37.20000 0.980000 2386 2340 77 163 5 ## 174 870 37 34.90000 0.960000 2237 2155 72 164 5 ## 175 875 42 35.00000 0.930000 2246 2099 70 164 5 ## 176 880 37 34.50000 0.890000 2216 1973 62 166 5 ## 177 885 43 39.40000 0.920000 2530 2331 78 167 5 ## 178 890 36 36.30000 0.920000 2333 2155 70 168 5 ## 179 895 43 39.00000 0.920000 2506 2299 74 168 5 ## 180 900 46 40.20000 0.930000 2583 2393 79 169 5 ## 181 905 44 38.80000 0.960000 2491 2384 79 170 5 ## 182 910 33 35.50000 0.900000 2277 2044 58 171 5 ## 183 915 42 41.20000 0.920000 2646 2447 78 172 5 ## 184 920 40 40.50000 0.960000 2598 2490 80 173 5 ## 185 925 45 34.70000 0.940000 2231 2107 68 173 5 ## 186 930 41 43.20000 0.950000 2776 2641 82 174 5 ## 187 935 44 42.20000 0.970000 2712 2627 84 174 5 ## 188 940 36 40.70000 0.990000 2615 2581 80 175 5 ## 189 945 32 40.80000 0.970000 2620 2529 74 176 5 ## 190 950 33 40.50000 0.970000 2597 2524 76 176 5 ## 191 955 37 42.00000 0.980000 2699 2638 81 176 5 ## 192 960 38 41.90000 1.000000 2692 2683 82 176 5 ## 193 965 48 40.10000 0.960000 2577 2471 78 176 5 ## 194 970 44 42.20000 0.970000 2710 2619 82 176 5 ## 195 975 46 41.90000 0.980000 2691 2628 83 176 5 ## 196 980 43 42.20000 1.000000 2712 2713 86 176 5 ## 197 985 37 39.90000 0.990000 2564 2528 76 176 5 ## 198 990 42 43.70000 0.990000 2805 2791 88 177 5 ## 199 995 45 42.30000 1.000000 2716 2728 88 178 5 ## 200 1000 41 41.10000 0.980000 2640 2587 79 178 5 ## 201 1005 44 43.60000 1.010000 2800 2823 91 178 5 ## 202 1010 46 40.90000 1.020000 2629 2672 89 179 5 ## 203 1015 47 41.90000 1.000000 2687 2700 86 179 5 ## 204 1020 41 40.20000 1.010000 2578 2606 81 179 5 ## 205 1025 47 38.70000 1.000000 2482 2476 81 179 5 ## 206 1030 46 27.60000 1.150000 1769 2037 87 179 5 ## 207 1035 37 20.30000 1.210000 1306 1583 63 180 5 ## 208 1040 39 22.90000 1.230000 1469 1802 75 181 5 ## 209 1045 37 21.30000 1.220000 1369 1666 67 183 5 ## 210 1050 38 21.20000 1.190000 1363 1621 64 184 5 ## 211 1055 48 21.30000 1.150000 1366 1571 64 184 6 ## 212 1060 54 40.90000 1.000000 2627 2627 81 183 6 ## 213 1065 46 39.30000 1.030000 2523 2603 84 181 6 ## 214 1070 42 34.40000 1.080000 2211 2379 78 176 6 ## 215 1075 42 37.20000 1.040000 2389 2480 82 173 6 ## 216 1080 43 37.10000 1.010000 2381 2400 81 172 6 ## 217 1085 44 38.20000 1.010000 2450 2469 86 171 6 ## 218 1090 43 37.20000 0.960000 2391 2301 78 172 6 ## 219 1095 46 40.60000 0.960000 2604 2503 86 173 6 ## 220 1100 46 40.40000 0.980000 2595 2551 89 174 6 ## 221 1105 46 40.20000 1.000000 2582 2579 90 176 6 ## 222 1110 43 41.10000 0.980000 2641 2595 88 177 6 ## 223 1115 43 40.80000 0.980000 2622 2582 86 179 6 ## 224 1120 46 42.40000 0.990000 2720 2689 90 180 6 ## 225 1125 43 42.70000 0.990000 2740 2715 89 180 6 ## 226 1130 43 42.20000 0.990000 2707 2674 87 181 6 ## 227 1135 42 43.00000 0.980000 2764 2698 85 181 6 ## 228 1140 45 42.40000 0.980000 2724 2673 85 181 6 ## 229 1145 45 45.90000 0.980000 2944 2899 93 181 6 ## 230 1150 46 42.70000 1.010000 2744 2780 94 181 6 ## 231 1155 45 42.10000 1.020000 2702 2750 91 182 6 ## 232 1160 37 42.30000 1.010000 2713 2748 85 183 6 ## 233 1165 46 43.10000 1.010000 2770 2790 91 184 6 ## 234 1170 51 42.00000 1.010000 2697 2718 91 184 6 ## 235 1175 51 45.30000 0.990000 2908 2884 93 184 6 ## 236 1180 41 43.40000 1.010000 2789 2811 88 184 6 ## 237 1185 46 43.80000 1.050000 2810 2937 100 184 6 ## 238 1190 46 44.50000 1.050000 2858 3002 99 185 6 ## 239 1195 45 44.90000 1.050000 2880 3016 99 185 6 ## 240 1200 46 44.90000 1.050000 2883 3034 100 185 6 ## 241 1205 46 43.50000 1.060000 2790 2953 98 185 6 ## 242 1210 46 43.50000 1.060000 2790 2962 100 186 6 ## 243 1215 45 43.80000 1.060000 2812 2979 99 186 6 ## 244 1220 46 45.30000 1.050000 2905 3051 101 186 6 ## 245 1225 45 43.60000 1.060000 2798 2969 100 186 6 ## 246 1230 46 43.40000 1.070000 2787 2973 101 186 6 ## 247 1235 48 36.20000 1.060000 2322 2472 88 186 6 ## 248 1240 45 27.00000 1.170000 1733 2030 87 187 6 ## 249 1245 42 22.20000 1.230000 1422 1749 76 188 6 ## 250 1250 47 27.60000 1.210000 1772 2144 88 188 6 ## 251 1255 52 26.50000 1.160000 1700 1971 83 189 6 ## 252 1260 47 26.30000 1.180000 1691 2003 86 189 6 ## 253 1265 62 28.90000 1.120000 1858 2082 84 189 7 ## 254 1270 46 44.30000 1.080000 2847 3067 98 188 7 ## 255 1275 47 39.30000 1.100000 2523 2782 95 184 7 ## 256 1280 46 37.80000 1.140000 2424 2759 100 181 7 ## 257 1285 48 39.10000 1.090000 2508 2742 101 180 7 ## 258 1290 46 40.10000 1.050000 2576 2702 99 180 7 ## 259 1295 46 41.50000 1.020000 2662 2722 101 180 7 ## 260 1300 40 39.10000 0.980000 2507 2450 82 181 7 ## 261 1305 46 44.20000 0.980000 2839 2786 101 182 7 ## 262 1310 47 43.70000 1.000000 2807 2805 104 183 7 ## 263 1315 46 43.10000 1.010000 2765 2790 101 184 7 ## 264 1320 44 43.00000 1.000000 2764 2777 97 185 7 ## 265 1325 46 45.00000 1.020000 2889 2936 104 186 7 ## 266 1330 46 43.40000 1.020000 2785 2842 99 186 7 ## 267 1335 49 43.40000 1.020000 2788 2856 102 187 7 ## 268 1340 47 44.00000 1.040000 2826 2933 104 187 7 ## 269 1345 43 42.20000 1.040000 2709 2829 94 188 7 ## 270 1350 46 47.50000 1.040000 3047 3167 106 188 7 ## 271 1355 46 45.00000 1.050000 2889 3026 102 188 7 ## 272 1360 49 43.80000 1.050000 2815 2957 102 189 7 ## 273 1365 46 45.00000 1.060000 2891 3054 102 189 7 ## 274 1370 47 46.00000 1.060000 2955 3132 106 189 7 ## 275 1375 46 45.00000 1.070000 2888 3093 105 190 7 ## 276 1380 45 43.60000 1.070000 2796 2984 98 190 7 ## 277 1385 47 47.20000 1.070000 3030 3239 108 190 7 ## 278 1390 46 45.50000 1.070000 2918 3136 105 190 7 ## 279 1395 46 46.30000 1.090000 2973 3238 108 191 7 ## 280 1400 46 44.50000 1.080000 2856 3096 103 191 7 ## 281 1405 46 44.80000 1.090000 2879 3145 105 192 7 ## 282 1410 46 44.90000 1.090000 2886 3133 105 192 7 ## 283 1415 46 45.20000 1.090000 2900 3166 105 192 7 ## 284 1420 54 45.60000 1.080000 2927 3160 109 192 7 ## 285 1425 56 45.10000 1.090000 2893 3148 109 192 7 ## 286 1430 55 46.20000 1.100000 2967 3263 112 192 7 ## 287 1435 57 46.50000 1.100000 2983 3290 114 193 7 ## 288 1440 59 44.40000 1.100000 2851 3148 113 193 7 ## 289 1445 54 38.20000 1.120000 2455 2744 101 193 7 ## 290 1450 52 29.10000 1.190000 1869 2224 96 194 7 ## 291 1455 53 27.60000 1.220000 1772 2163 96 194 7 ## 292 1460 53 27.30000 1.200000 1755 2101 91 194 7 ## 293 1465 44 25.40000 1.200000 1628 1955 75 194 7 ## 294 1470 49 29.10000 1.200000 1869 2240 94 193 7 ## 295 1475 45 24.00000 1.230000 1541 1890 84 192 8 ## 296 1480 69 38.70000 1.100000 2485 2740 100 191 8 ## 297 1485 53 43.70000 1.160000 2806 3249 108 191 8 ## 298 1490 49 39.90000 1.210000 2562 3095 109 188 8 ## 299 1495 54 40.40000 1.140000 2593 2958 109 187 8 ## 300 1500 47 40.70000 1.100000 2613 2875 107 185 8 ## 301 1505 51 41.40000 1.050000 2657 2799 107 187 8 ## 302 1510 54 44.70000 1.020000 2870 2919 112 188 8 ## 303 1515 58 44.90000 1.010000 2882 2906 110 189 8 ## 304 1520 52 45.30000 1.020000 2910 2979 111 190 8 ## 305 1525 54 45.30000 1.030000 2910 3006 111 191 8 ## 306 1530 54 45.30000 1.040000 2907 3031 111 191 8 ## 307 1535 62 45.30000 1.030000 2906 2998 113 192 8 ## 308 1540 52 44.50000 1.060000 2855 3035 111 192 8 ## 309 1545 61 45.90000 1.050000 2944 3093 114 193 8 ## 310 1550 54 44.70000 1.020000 2870 2919 112 193 8 ## 311 1555 58 44.90000 1.010000 2882 2906 110 193 8 ## 312 1560 59 45.42188 1.042656 2907 3031 110 190 8 ## 313 1565 55 45.40625 1.031659 2906 2998 111 191 8 ## 314 1570 52 44.60938 1.063047 2855 3035 111 191 8 ## 315 1575 54 46.00000 1.050611 2944 3093 112 192 8 ## 316 1580 53 44.84375 1.017073 2870 2919 111 192 8 ## 317 1585 56 45.03125 1.008328 2882 2906 111 190 8 ## 318 1590 57 45.42188 1.042656 2907 3031 112 191 8 ## 319 1595 60 45.40625 1.031659 2906 2998 112 191 8 ## 320 1600 54 44.60938 1.063047 2855 3035 111 192 8 ## 321 1605 57 46.00000 1.050611 2944 3093 113 192 8 ## 322 1610 56 44.84375 1.017073 2870 2919 111 193 8 ## 323 1615 59 45.03125 1.008328 2882 2906 112 193 8 ## 324 1620 62 45.40625 1.031659 2906 2998 113 193 8 ## 325 1625 55 45.31250 1.068966 2900 3100 112 194 8 ## 326 1630 57 45.32812 1.034126 2901 3000 111 195 8 ## 327 1635 52 44.60938 1.063047 2855 3035 111 194 8 ## 328 1640 59 46.50000 1.041667 2976 3100 112 197 8 ## 329 1645 60 45.14062 1.067844 2889 3085 113 196 8 ## 330 1650 61 46.00000 1.050611 2944 3093 114 195 8 6.5.3 Discussion Why chunks of 210 sec? Vo2 data analysis, requires you to find the average values of the last 30s of each treadmill testing stage. Based on your Autumn School lessons, recall that each stage is 3 min 30 sec long or 210 sec. When doing data analysis, there is an amount of pre-planning on how to get the desired end product. There is no magic pill, the more analysis you do, the more short cuts you know. 6.6 Tidy data You can represent the same underlying data in multiple ways. The example below shows the same data organised in four different ways. This dataset is not the data you loaded, but rather came with the tidyverse package. Each dataset shows the same values of four variables country, year, population, and cases, but each dataset organises the values in a different way. table1 ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 table2 ## # A tibble: 12 x 4 ## country year type count ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 cases 745 ## 2 Afghanistan 1999 population 19987071 ## 3 Afghanistan 2000 cases 2666 ## 4 Afghanistan 2000 population 20595360 ## 5 Brazil 1999 cases 37737 ## 6 Brazil 1999 population 172006362 ## 7 Brazil 2000 cases 80488 ## 8 Brazil 2000 population 174504898 ## 9 China 1999 cases 212258 ## 10 China 1999 population 1272915272 ## 11 China 2000 cases 213766 ## 12 China 2000 population 1280428583 table3 ## # A tibble: 6 x 3 ## country year rate ## * &lt;chr&gt; &lt;int&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 # Spread across two tables table4a # cases ## # A tibble: 3 x 3 ## country `1999` `2000` ## * &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 745 2666 ## 2 Brazil 37737 80488 ## 3 China 212258 213766 table4b # population ## # A tibble: 3 x 3 ## country `1999` `2000` ## * &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 19987071 20595360 ## 2 Brazil 172006362 174504898 ## 3 China 1272915272 1280428583 These are all representations of the same underlying data, but they are not equally easy to use. One dataset, the tidy dataset, will be much easier to work with. There are three interrelated rules which make a dataset tidy: Each variable must have its own column. Each observation must have its own row. Each value must have its own cell. Figure 6.1 shows the rules visually. Figure 6.1: Following three rules makes a dataset tidy: variables are in columns, observations are in rows, and values are in cells. These three rules are interrelated because it’s impossible to only satisfy two of the three. In this example, only table1 is tidy. It’s the only representation where each column is a variable. Why ensure that your data is tidy? There are two main advantages: There’s a general advantage to picking one consistent way of storing data. If you have a consistent data structure, it’s easier to learn the tools that work with it because they have an underlying uniformity. There’s a specific advantage to placing variables in columns because most of R functions work with data in the tidy format. That makes transforming tidy data feel particularly natural. The principles of tidy data seem so obvious that you might wonder if you’ll ever encounter a dataset that isn’t tidy. Unfortunately, however, most data that you will encounter will be untidy. There are two main reasons: Most people aren’t familiar with the principles of tidy data, and it’s hard to derive them yourself unless you spend a lot of time working with data. Data is often organised to facilitate some use other than analysis. For example, data is often organised to make entry as easy as possible. This means for most real analyses, you’ll need to do some tidying. The first step is always to figure out what the variables and observations are. Sometimes this is easy; other times you’ll need to consult with the people who originally generated the data. The second step is to resolve one of two common problems: One variable might be spread across multiple columns. One observation might be scattered across multiple rows. Typically a dataset will only suffer from one of these problems; it’ll only suffer from both if you’re really unlucky! To fix these problems, you’ll need the two most important functions in tidyr: pivot_wider() and pivot_longer(). 6.7 Spreading 6.7.1 Problem You want to make your data wider, in this instance let us look at the dat_fms dataset. You want to have one column indicating the left FMS score, and one indicating the right FMS score. The caveat is that because some tasks in the FMS do not have left and right, we need to remove the tasks in the FMS without a left and right. In this case, we will use the filter() function, which will be discussed in Recipe 6.12. dat_fms_sub &lt;- dat_fms %&gt;% filter (side != &quot;c&quot;) dat_wide &lt;- dat_fms_sub %&gt;% # original data pivot_wider(names_from = &quot;side&quot;, values_from = score) dat_wide ## # A tibble: 5 x 3 ## task l r ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 hurdle 2 2 ## 2 lunge 3 3 ## 3 leg_raise 2 1 ## 4 shd_mob 1 2 ## 5 rot_stab 2 2 6.8 Gathering 6.8.1 Problem You want to make your data longer. In this instance, if you have for example a left and right FMS column and you want to bring all into one column, you use the pivot_longer() function. 6.8.2 Solution dat_long &lt;- dat_wide %&gt;% # original data pivot_longer(cols = c(&quot;l&quot;, &quot;r&quot;), names_to = &quot;side&quot;, values_to = &quot;score&quot;) dat_long ## # A tibble: 10 x 3 ## task side score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 hurdle l 2 ## 2 hurdle r 2 ## 3 lunge l 3 ## 4 lunge r 3 ## 5 leg_raise l 2 ## 6 leg_raise r 1 ## 7 shd_mob l 1 ## 8 shd_mob r 2 ## 9 rot_stab l 2 ## 10 rot_stab r 2 6.9 Rename values of a variable 6.9.1 Problem You want to rename some values, either because it is too long, too short, or for other reasons. In this instance, in the dat_fms dataset, you want to call l, left, and r, right. 6.9.2 Solution Use the mutate() function and the recode() function. You will learn the mutate () function more in Recipe 6.11. dat_fms &lt;- dat_fms %&gt;% mutate (side = recode (side, # the variable name &quot;l&quot; = &quot;left&quot;, # old label = new label &quot;r&quot; = &quot;right&quot;)) # old label = new label dat_fms ## task side score ## 1 squat c 3 ## 2 hurdle left 2 ## 3 hurdle right 2 ## 4 lunge left 3 ## 5 lunge right 3 ## 6 leg_raise left 2 ## 7 leg_raise right 1 ## 8 shd_mob left 1 ## 9 shd_mob right 2 ## 10 rot_stab left 2 ## 11 rot_stab right 2 ## 12 push_up c 1 6.10 Creating factors 6.10.1 Problem You want to create an order in the values of a variable - like small, medium, large. 6.10.2 Solution # Order of values I desire new_lvls &lt;- c( &quot;push_up&quot;,&quot;squat&quot;, &quot;rot_stab&quot;, &quot;hurdle&quot;, &quot;lunge&quot;, &quot;leg_raise&quot;, &quot;shd_mob&quot;) dat_fms_relvl &lt;- dat_fms %&gt;% mutate (task = factor (task, levels = new_lvls)) 6.10.3 Discussion Why do you need to convert categorical variables to factors? For visualization, the simple reason is that it allows you to control the order in which items appear first to last. Of course, it has important statistical reasons, of which we do not discuss presently. # Without factor ggplot(dat_fms) + geom_col(aes(x = task, y = score, fill = side), position = &quot;dodge&quot;, color = &quot;black&quot;) # With factor new levels ggplot(dat_fms_relvl) + geom_col(aes(x = task, y = score, fill = side), position = &quot;dodge&quot;, color = &quot;black&quot;) Figure 6.2: Barplots of FMS score on original dat_fms (left); and new dat_fms_relvl when with modified the task variable to be a factor, with new levels (right). 6.11 Making a new variable 6.11.1 Problem You want to create a new column which involves some math between columns 6.11.2 Solution Example, you want to create a column called ratio in the dat_vo2 dataset, by dividing vo2 by vco2. dat_vo2 &lt;- dat_vo2 %&gt;% mutate (ratio = vo2/vco2) head(dat_vo2) ## time bf vo2_norm rer vo2 vco2 ve hr stage ratio ## 1 5 37 21.4 0.93 1371 1272 46 119 1 1.077830 ## 2 10 58 2.5 0.84 159 133 12 120 1 1.195489 ## 3 15 30 23.5 0.74 1506 1110 35 121 1 1.356757 ## 4 20 34 22.4 0.86 1437 1229 43 123 1 1.169243 ## 5 25 23 15.6 0.73 1004 735 22 124 1 1.365986 ## 6 30 27 30.5 0.76 1960 1489 48 124 1 1.316320 6.11.3 Discussion There are many math operations you can do including subtraction (-), multiplication (*), addition (+), exponentiation/power to the power of 2 (^2). Let us go crazy and try some random creation of new variables. dat_vo2_crazy &lt;- dat_vo2 %&gt;% mutate (vo2_power = vo2^3,# vo2 powered to 3 vco2_mod = vco2/3, # vco2 divied by 3 junk = (vo2+ vco2)/ (hr + bf) # divided the sum of vo2 and vco2, and sum of hr and bf ) head(dat_vo2_crazy) ## time bf vo2_norm rer vo2 vco2 ve hr stage ratio vo2_power vco2_mod ## 1 5 37 21.4 0.93 1371 1272 46 119 1 1.077830 2576987811 424.00000 ## 2 10 58 2.5 0.84 159 133 12 120 1 1.195489 4019679 44.33333 ## 3 15 30 23.5 0.74 1506 1110 35 121 1 1.356757 3415662216 370.00000 ## 4 20 34 22.4 0.86 1437 1229 43 123 1 1.169243 2967360453 409.66667 ## 5 25 23 15.6 0.73 1004 735 22 124 1 1.365986 1012048064 245.00000 ## 6 30 27 30.5 0.76 1960 1489 48 124 1 1.316320 7529536000 496.33333 ## junk ## 1 16.942308 ## 2 1.640449 ## 3 17.324503 ## 4 16.980892 ## 5 11.829932 ## 6 22.841060 6.12 Filtering Filtering is removing rows you do not want and keeping rows you want based on some condition(s). In Recipe 6.2, you learnt the slice() function. That is for really simple filtering. The filter() function you will learn here gives you more flexibility, which you will learnt in a bit. Filtering deals with keeping or throwing out rows of data. Keeping or throwing out columns of data uses the select() function, which you will learn in Recipe 6.2. 6.12.1 Keep rows you want based on condition 6.12.1.1 Problem In the dat_fms dataset, you want to keep rows that have side == \"left\" (i.e. only rows where the side value equals left). Note the ==, double equal sign, instead of the usual =. In this short book, I will not go at length to explain why R is so difficult, only that I ask you to obey the rules of the language. 6.12.1.2 Solution dat_fms %&gt;% filter (side == &quot;left&quot;) ## task side score ## 1 hurdle left 2 ## 2 lunge left 3 ## 3 leg_raise left 2 ## 4 shd_mob left 1 ## 5 rot_stab left 2 6.12.2 Keep rows based on a numerical range You want to keep the data when a variable is within a certain window range. Let us use the dat_vo2 dataset. Let us see the range of values of ve. hist (dat_vo2$ve) 6.12.2.1 Problem Say I want to keep rows where 1) ve is less than 80, 2) ve more than 40, and 3) ve is between 40 to 80 6.12.2.2 Solution Notice for each graph, how the minimum and maximum values have been clipped off. # ve less than 80 dat_vo2_filt &lt;- dat_vo2 %&gt;% filter (ve &lt; 80) hist (dat_vo2_filt$ve) # ve lmore than 40 dat_vo2_filt &lt;- dat_vo2 %&gt;% filter (ve &gt; 40) hist (dat_vo2_filt$ve) # ve between 40 to 80 dat_vo2_filt &lt;- dat_vo2 %&gt;% filter (ve &gt; 40 &amp; ve &lt; 80) hist (dat_vo2_filt$ve) 6.12.3 Discussion filter() works really when you want to throw out or keep rows of data based on some ranges or criteria of the variables you have. When you want to keep rows of data based on the row number, say keep the first and last row of data, use slice (). See also Recipe 6.2. dat_vo2 %&gt;% slice(tail(row_number(), 6)) ## time bf vo2_norm rer vo2 vco2 ve hr stage ratio ## 1 1625 55 45.31250 1.068966 2900 3100 112 194 8 0.9354839 ## 2 1630 57 45.32812 1.034126 2901 3000 111 195 8 0.9670000 ## 3 1635 52 44.60938 1.063047 2855 3035 111 194 8 0.9406919 ## 4 1640 59 46.50000 1.041667 2976 3100 112 197 8 0.9600000 ## 5 1645 60 45.14062 1.067844 2889 3085 113 196 8 0.9364668 ## 6 1650 61 46.00000 1.050611 2944 3093 114 195 8 0.9518267 6.13 Global summary 6.13.1 Problem You want to find the total FMS score across all sides and tasks 6.13.2 Solution In the dat_fms dataset, we want to use the summarize () function. dat_fms %&gt;% summarize (total_score = sum (score)) ## total_score ## 1 24 I date you to find an easier way to calculate such scores in one line of code. That is one reason why I use a programming language like R. It is fast!!! 6.13.3 Discussion We can also go berserk by trying out different summary functions, like mean (), median (), min() (minimum value), max (maximum value). dat_fms %&gt;% summarize (total_score = sum (score), mean_score = mean (score), median_score = median (score), min_score = min (score), max_score = max(score)) ## total_score mean_score median_score min_score max_score ## 1 24 2 2 1 3 6.14 Group-by summary 6.14.1 Problem You want to perform a summary function for each chunk of group. For example, the FMS is typically scored by taking the lower of the two values of left and right for each task. In side, we have three values, c, left and right. The minimum of c is the same value itself. 6.14.2 Solution In the dat_fms dataset, we want to use the group_by() and summarize () function.The code below reads as: for each task, tell me the lowest value. For the task of leg raise, the lower of the two values is 1. And you will indeed see that has been created. dat_fms %&gt;% group_by(task) %&gt;% summarize (lower_score = min (score)) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 7 x 2 ## task lower_score ## &lt;chr&gt; &lt;dbl&gt; ## 1 hurdle 2 ## 2 leg_raise 1 ## 3 lunge 3 ## 4 push_up 1 ## 5 rot_stab 2 ## 6 shd_mob 1 ## 7 squat 3 6.14.3 Discussion Why do you need to learn to create summaries? It is the basis for genering plots easily. Let us look at the dat_vo2 dataset. Remember in your lessons, the last 30 sec of each 3 min 30 sec stage is discarded, and the last 30s of each 3 min interval is than averaged for further analysis? Well, it means that for each stage, I want to keep data between 2:30 to 3min of each stage. That corresponds to rows 31 to 36 of each stage (try to think why i selected these row numbers!). I than want to average all my variables over these 6 rows per stage. I should end up with a dataframe that has 8 rows given 8 stages, one for each stage in this example. Notice how I use the summarize_at() function? Because I want to average so many variables, I become lazy. So I specific all variable names without \"\" inside the vars(). Note I did not type out bf, vo2_norm, rer, vo2, vco2, ve, hr. I used a short cut called :, which reads as from start to end. So bf:hr, means all columns from bf to hr, inclusive. dat_vo2_summ &lt;- dat_vo2 %&gt;% group_by(stage) %&gt;% # for each group slice(c(31:36)) %&gt;% summarise_at (vars(bf:hr), mean) 6.15 Merge two tables together 6.15.1 Problem You want to combine two tables together, ensuring the each row is linked appropriately. For example, you want to combine your dat_vo2_summ summary data with the dat_vo2_stage table which contains the RPE and blood lactate values. 6.15.2 Solution Use the inner_join function, with the by key as the common identifier that must be in both dataframes. dat_vo2_summ %&gt;% inner_join(dat_vo2_stage, by = &quot;stage&quot;) ## # A tibble: 8 x 11 ## stage bf vo2_norm rer vo2 vco2 ve hr speed rpe lactate ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 30.7 32.0 0.868 2053. 1778. 55.2 136. 1 10 1 ## 2 2 34.7 34.6 0.882 2222. 1958. 59.3 147 2 11 1.5 ## 3 3 34.7 37.4 0.912 2402. 2191. 66.7 161. 3 12 1.8 ## 4 4 38 37.8 0.95 2429 2312. 71.2 172. 4 13 2.5 ## 5 5 44 41.7 1.00 2675 2686 85.7 178. 5 14 6 ## 6 6 45.7 43.8 1.06 2814. 2981. 99.8 186. 6 15 7.7 ## 7 7 54.5 45.5 1.09 2920. 3196. 110. 192. 7 16 9 ## 8 8 57.3 45.5 1.05 2911. 3069. 112. 195. 8 17 10 6.15.3 Discussion It is common sense, that if we want to join two tables, there must be some rules. First, if we want to join two tables side by side left-right, the number of rows must match. Second, there must be a way the computer knows how to join, much like a key and a keyhole. The key is the column to join by, in this example, stage. In the dat_vo2_summ there is the stage variable with identical number of levels 1-8, and the same variable appears in dat_vo2_stage. You don’t have to worry if after merging, the data is sorted correctly, if you follow these rules. 6.16 Learning check From your learning check in 5.4, open up your practice_script.R. You should already have the codes to import the data/treadmill_pt4.xlsx file. Rename the columns to be (\"time\", \"bf\", \"vo2_norm\", \"rer\", \"vo2\", \"vco2\", \"ve\", \"hr\"), respectively. See Recipe 6.1. Remove the first two useless rows of the data. See Recipe 6.2. Convert the variable time into numeric seconds, and all other variables to numeric. See Recipe 6.4 and 6.3, respectively. ## Warning: package &#39;igraph&#39; was built under R version 3.6.3 ## Warning: package &#39;MASS&#39; was built under R version 3.6.3 "],
["CHAPTER-BAR-GRAPH.html", "Chapter 7 Bar Graphs 7.1 Making a Basic Bar Graph 7.2 Grouping Bars Together 7.3 Using Colors in a Bar Graph 7.4 Changing Axes titles in a Bar Graph 7.5 Changing Legend titles in a Bar Graph 7.6 Changing font size uniformly across the Bar Graph 7.7 Outputting to Bitmap (PNG/TIFF) Files 7.8 Learning check", " Chapter 7 Bar Graphs Bar graphs are perhaps the most commonly used kind of data visualization. They’re typically used to display numeric values (on the y-axis), for different categories (on the x-axis). For example, a bar graph would be good for showing the prices of four different kinds of items. A bar graph generally wouldn’t be as good for showing prices over time, where time is a continuous variable – though it can be done. There’s an important distinction you should be aware of when making bar graphs: sometimes the bar heights represent counts of cases in the data set, and sometimes they represent values in the data set. Keep this distinction in mind – it can be a source of confusion since they have very different relationships to the data, but the same term is used for both of them. In this chapter I’ll discuss always use bar graphs with values. Let us prepare for this chapter by first importing a FMS test data that we have cleaned, and placed in the data folder. The Excel sheet is called \"fms_pt3.xlsx\" dat &lt;- read.xlsx (xlsxFile = &quot;data/fms_pt3.xlsx&quot;, sheet = &quot;Sheet1&quot;) fct_lvls &lt;- c(&quot;squat&quot;, &quot;push_up&quot;, &quot;hurdle&quot;, &quot;lunge&quot;, &quot;leg_raise&quot;, &quot;rot_stab&quot;, &quot;shd_mob&quot;) dat &lt;- dat %&gt;% mutate (task = factor (task, levels = fct_lvls)) dat #&gt; task side score #&gt; 1 squat c 3 #&gt; 2 hurdle l 2 #&gt; 3 hurdle r 2 #&gt; ...&lt;6 more rows&gt;... #&gt; 10 rot_stab l 2 #&gt; 11 rot_stab r 2 #&gt; 12 push_up c 1 Let us also create another dataset where we take the lower of the two scores for tasks which are assessed bilaterally. See Recipe 6.14. dat_summ &lt;- dat %&gt;% group_by(task) %&gt;% summarize (total = min (score)) %&gt;% ungroup () #&gt; `summarise()` ungrouping output (override with `.groups` argument) dat_summ #&gt; # A tibble: 7 x 2 #&gt; task total #&gt; &lt;fct&gt; &lt;dbl&gt; #&gt; 1 squat 3 #&gt; 2 push_up 1 #&gt; 3 hurdle 2 #&gt; 4 lunge 3 #&gt; 5 leg_raise 1 #&gt; 6 rot_stab 2 #&gt; # ... with 1 more row 7.1 Making a Basic Bar Graph 7.1.1 Problem You have a data frame where one column represents the x position of each bar, and another column represents the vertical y height of each bar. 7.1.2 Solution Use ggplot() with geom_col() and specify what variables you want on the x- and y-axes (Figure 7.1): ggplot(dat_summ) + geom_col(aes(x = task, y = total)) Figure 7.1: Bar graph of values with a discrete x-axis 7.1.3 Discussion By default, bar graphs use a dark grey for the bars. To use a color fill, use fill. Also, by default, there is no outline around the fill. To add an outline, use colour. For Figure 7.2, we use a light blue fill and a black outline: ggplot(dat_summ) + geom_col(aes(x = task, y = total), fill = &quot;lightblue&quot;, colour = &quot;black&quot;) Figure 7.2: A single fill and outline color for all bars Note In ggplot2, the default is to use the British spelling, colour, instead of the American spelling, color. Internally, American spellings are remapped to the British ones, so if you use the American spelling it will still work. 7.2 Grouping Bars Together 7.2.1 Problem You want to group bars together by a second variable. 7.2.2 Solution Map a variable to fill, and use geom_col(position = \"dodge\"). In this example we’ll use the dat data set, in which we have an FMS score one for each side. We’ll map task to the x position and map side to the fill color (Figure 7.3): ggplot(dat) + geom_col(aes(x = task, y = score, fill = side), position = &quot;dodge&quot;) Figure 7.3: Graph with grouped bars 7.2.3 Discussion The most basic bar graphs have one categorical variable on the x-axis and one continuous variable on the y-axis. Sometimes you’ll want to use another categorical variable to divide up the data, in addition to the variable on the x-axis. You can produce a grouped bar plot by mapping that variable to fill, which represents the fill color of the bars. You must also use position = \"dodge\", which tells the bars to “dodge” each other horizontally; if you don’t, you’ll end up with a stacked bar plot. Try remove this argument position = \"dodge\", and see what happens! As with variables mapped to the x-axis of a bar graph, variables that are mapped to the fill color of bars must be categorical rather than continuous variables. Other aesthetics, such as colour (the color of the outlines of the bars), can also be used for grouping variables, but fill is probably what you’ll want to use. 7.3 Using Colors in a Bar Graph 7.3.1 Problem You want to use different colors for the bars in your graph.The default colors aren’t the most appealing, so you may want to set them using scale_fill_manual(). We’ll set the outline color of the bars to black, with colour=\"black\" (Figure 7.4). 7.3.2 Solution Map the appropriate variable to the fill aesthetic (Figure 7.4). ggplot(dat) + geom_col(aes(x = task, y = score, fill = side), position = &quot;dodge&quot;, color = &quot;black&quot;) + scale_fill_manual(values = c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;)) Figure 7.4: Graph with different colors, black outlines, and sorted by percentage change 7.3.3 Discussion In the variable side, there are three values - c, l, r. How does R know if the red is for what value, and ditto for other colors. Well, if you did not specify the levels, it goes in alphabetical order. So \"red\"\" is for c, and \"green\" is for r. See Recipe 6.10 for how to change the order of levels in a factor. There are plethora of color names that is availabe in R and that you can select to be used in scale_fill_manual (Figure 7.5). Figure 7.5: Names of many colors available in R. 7.4 Changing Axes titles in a Bar Graph 7.4.1 Problem You want to use a different name to label each axis. Some may simply want to use the same names with capitalizations, or totally different names, especially if abbreviations are used in your spreadsheet. For this we will be using the labs() function. 7.4.2 Solution Map the appropriate variable to the fill aesthetic (Figure 7.6). ggplot(dat) + geom_col(aes(x = task, y = score, fill = side), position = &quot;dodge&quot;, color = &quot;black&quot;) + scale_fill_manual(values = c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;)) + labs (x = &quot;Tasks&quot;, y = &quot;FMS Score&quot;) Figure 7.6: Graph different axes titles 7.5 Changing Legend titles in a Bar Graph 7.5.1 Problem You want to use a different name for the legend title. Some may simply want to use the same names with capitalizations, or totally different names, especially if abbreviations are used in your spreadsheet. For this we will be using the labs() function, and within it the fill argument. In this example, the visual component that separates different sides was the fill color, that is why we changed the name of the fill component. 7.5.2 Solution Map the appropriate variable to the fill aesthetic (Figure 7.7). ggplot(dat) + geom_col(aes(x = task, y = score, fill = side), position = &quot;dodge&quot;, color = &quot;black&quot;) + scale_fill_manual(values = c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;)) + labs (x = &quot;Tasks&quot;, y = &quot;FMS Score&quot;, fill = &quot;Side&quot;) Figure 7.7: Graph different legend title 7.6 Changing font size uniformly across the Bar Graph 7.6.1 Problem You want to magnify the font size for the axes titles, axes labels, legend title, and legend labels. In this case you can use the theme(text = element_text(size=) function. For advance users which is not convered in this book, you can actually custom the fontsize of each and every component to be different. 7.6.2 Solution Map the appropriate variable to the fill aesthetic (Figure 7.8). ggplot(dat) + geom_col(aes(x = task, y = score, fill = side), position = &quot;dodge&quot;, color = &quot;black&quot;) + scale_fill_manual(values = c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;)) + labs (x = &quot;Tasks&quot;, y = &quot;FMS Score&quot;, fill = &quot;Side&quot;) + theme(text = element_text(size= 16)) Figure 7.8: Graph with font size = 16 7.7 Outputting to Bitmap (PNG/TIFF) Files 7.7.1 Problem You want to create a bitmap of your plot, writing to a PNG file. 7.7.2 Solution We will be using ggsave(). First we need to assign the gplot we created with ggplot() to an object, which we can name anything. Here we call the object simply f. There are several important arguments you need. filename is the name of the file and extension you want your image to be called. Here we will use filename = \"my_plot.png\". plot is the specific figure you want to save. Hwere we will use plot = f. width and height allows you to specify how big your image is. unit is whether your width and height are defined in centimeters, \"cm\", or inches, \"in\". Here I will use units = \"cm\", and a 8 cm by 4 cm width and height, respectively. Lastly, the dpi argument specifies the resoultion of the image. Here we use dpi = 300. The file is saved to the working directory of the session. f &lt;- ggplot(dat) + geom_col(aes(x = task, y = score, fill = side), position = &quot;dodge&quot;, color = &quot;black&quot;) + scale_fill_manual(values = c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;)) + labs (x = &quot;Tasks&quot;, y = &quot;FMS Score&quot;, fill = &quot;Side&quot;) + theme(text = element_text(size= 16)) # Default dimensions are in inches, but you can specify the unit ggsave(filename = &quot;myplot.png&quot;, plot = f, # the name of the image object you created above. width = 8, height = 8, unit = &quot;cm&quot;, dpi = 300) 7.7.3 Discussion For high-quality print output, use at least 300 ppi. Figure 7.9 shows portions of the same plot at different resolutions. Figure 7.9: From left to right: PNG output at 72, 150, and 300 ppi (actual size) R supports other bitmap formats, like BMP, TIFF, and JPEG, but there’s really not much reason to use them instead of PNG. The exact appearance of the resulting bitmaps varies from platform to platform. Unlike R’s PDF output device, which renders consistently across platforms, the bitmap output devices may render the same plot differently on Windows, Linux, and Mac OS X. There can even be variation within each of these operating systems. 7.8 Learning check From your learning check in @ref (WRANGLE-LEARNING-CHECK), open up your practice_script.R. Import the Excel file data/fms_pt3.xlsx, and assign it to an object dat. See Recipe 5.2. Create another dataset, dat_summ where we take the lower of the two scores for tasks which are assessed bilaterally. See Recipe 6.14. Using the data dat_summ, create a barplot of task as the x axis, and the total FMS score as the y axis. See Recipe 7.1. Make the line colour \"red\", and fill the barplot with the colour \"blue\". See 7.2. "],
["line-graphs.html", "Chapter 8 Line Graphs 8.1 Making a Basic Line Graph 8.2 Adding Points to a Line Graph 8.3 Making a Line Graph with Multiple Lines 8.4 Changing the Appearance of Lines 8.5 Changing the Appearance of Points 8.6 Using Themes to Change Overall Appearance of Plot 8.7 Learning check", " Chapter 8 Line Graphs Line graphs are typically used for visualizing how one continuous variable, on the y-axis, changes in relation to another continuous variable, on the x-axis. Often the x variable represents time, but it may also represent some other continuous quantity, for example, the amount of a drug administered to experimental subjects. As with bar graphs, there are exceptions. Line graphs can also be used with a discrete variable on the x-axis. This is appropriate when the variable is ordered (e.g., “small”, “medium”, “large”), but not when the variable is unordered (e.g., “cow”, “goose”, “pig”). Most of the examples in this chapter use a continuous x variable, but we’ll see one example where the variable is converted to a factor and thus treated as a discrete variable. Let us prepare for this chapter by first importing a Vo2 treadmill test data that we have cleaned, and placed in the data folder. See Recipe 6.14. The Excel sheet is called \"treadmill_pt4_clean.xlsx\". dat &lt;- read.xlsx (xlsxFile = &quot;data/treadmill_pt4_clean.xlsx&quot;, sheet = &quot;Sheet1&quot;) dat &lt;- dat %&gt;% mutate (stage = cut_interval(time, length = 210, labels = FALSE)) %&gt;% group_by(stage) %&gt;% group_by(stage) %&gt;% slice(-c(37:42)) %&gt;% slice(tail(row_number(), 6)) %&gt;% summarise_at (vars(bf:hr), mean) 8.1 Making a Basic Line Graph 8.1.1 Problem You want to make a basic line graph. 8.1.2 Solution Use ggplot() with geom_line(), and specify which variables you mapped to x and y (Figure 8.1): ggplot(dat) + geom_line(aes(x = stage, y = vo2)) Figure 8.1: Basic line graph 8.1.3 Discussion In this sample data set, the x variable, time, is in one column and the y variable, vo2, is in another: dat #&gt; # A tibble: 8 x 8 #&gt; stage bf vo2_norm rer vo2 vco2 ve hr #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 30.7 32.0 0.868 2053. 1778. 55.2 136. #&gt; 2 2 34.7 34.6 0.882 2222. 1958. 59.3 147 #&gt; 3 3 34.7 37.4 0.912 2402. 2191. 66.7 161. #&gt; 4 4 38 37.8 0.95 2429 2312. 71.2 172. #&gt; 5 5 44 41.7 1.00 2675 2686 85.7 178. #&gt; 6 6 45.7 43.8 1.06 2814. 2981. 99.8 186. #&gt; # ... with 2 more rows With ggplot2, the default y range of a line graph is just enough to include the y values in the data. For some kinds of data, it’s better to have the y range start from zero. You can use ylim() to set the range, or you can use expand_limits() to expand the range to include a value. This will set the range from zero to the maximum value of the demand column in BOD (Figure 8.2): # These have the same result ggplot(dat) + geom_line(aes(x = stage, y = vo2)) + ylim(0, max(dat$vo2)) ggplot(dat) + geom_line(aes(x = stage, y = vo2)) + expand_limits(y = 0) Figure 8.2: Line graph with manually set y range 8.2 Adding Points to a Line Graph 8.2.1 Problem You want to add points to a line graph. 8.2.2 Solution Add geom_point() (Figure 8.3): ggplot(dat) + geom_line(aes(x = stage, y = vo2)) + geom_point(aes(x = stage, y = vo2)) Figure 8.3: Line graph with points 8.2.3 Discussion Sometimes it is useful to indicate each data point on a line graph. This is helpful when the density of observations is low, or when the observations do not happen at regular intervals. In an external worldpop data set that comes with the installed packages, the intervals between each data point are not consistent. In the far past, the estimates were not as frequent as they are in the more recent past. Displaying points on the graph illustrates when each estimate was made (Figure 8.4): library(gcookbook) # Load gcookbook for the worldpop data set ggplot(worldpop) + geom_line(aes(x = Year, y = Population)) + geom_point(aes(x = Year, y = Population)) # Same with a log y-axis ggplot(worldpop) + geom_line(aes(x = Year, y = Population)) + geom_point(aes(x = Year, y = Population)) + scale_y_log10() Figure 8.4: Top: points indicate where each data point is; bottom: the same data with a log y-axis With the log y-axis, you can see that the rate of proportional change has increased in the last thousand years. The estimates for the years before 0 have a roughly constant rate of change of 10 times per 5,000 years. In the most recent 1,000 years, the population has increased at a much faster rate. We can also see that the population estimates are much more frequent in recent times–and probably more accurate! 8.3 Making a Line Graph with Multiple Lines 8.3.1 Problem You want to make a line graph with more than one line. 8.3.2 Solution In addition to the variables mapped to the x- and y-axes, map another (discrete) variable to colour or linetype, as shown in Figure 8.5: # Bring all variables into one column dat_long &lt;- dat %&gt;% pivot_longer(cols = c(bf:hr), names_to = &quot;var&quot;, values_to = &quot;val&quot;) %&gt;% filter (var %in% c(&quot;vco2&quot;, &quot;vo2&quot;)) %&gt;% mutate (var = factor (var)) # Map supp to colour ggplot(dat_long) + geom_line(aes(x = stage, y = val, colour = var)) # Map supp to linetype ggplot(dat_long) + geom_line(aes(x = stage, y = val, linetype = var)) Figure 8.5: A variable mapped to colour (left); A variable mapped to linetype (right) 8.3.3 Discussion The dat_long data has three columns, including the factor var, which we mapped to colour and linetype: dat_long #&gt; # A tibble: 16 x 3 #&gt; stage var val #&gt; &lt;int&gt; &lt;fct&gt; &lt;dbl&gt; #&gt; 1 1 vo2 2053. #&gt; 2 1 vco2 1778. #&gt; 3 2 vo2 2222. #&gt; 4 2 vco2 1958. #&gt; 5 3 vo2 2402. #&gt; 6 3 vco2 2191. #&gt; # ... with 10 more rows Note If the x variable is a factor, you must also tell ggplot to group by that same variable, as described below. Line graphs can be used with a continuous or categorical variable on the x-axis. Sometimes the variable mapped to the x-axis is conceived of as being categorical, even when it’s stored as a number. In the example here, there are eight values of stage: 1, 2, 3, 4, 5, 6, 7, 8. You may want to treat these as categories rather than values on a continuous scale. To do this, convert stage to a factor (Figure 8.6): ggplot(dat_long) + geom_line(aes(x = factor (stage), y = val, colour = var, group = var)) Figure 8.6: Line graph with continuous x variable converted to a factor To convert a variable to a factor , see also Recipe 6.10. Notice the use of group = ar. Without this statement, ggplot won’t know how to group the data together to draw the lines, and it will give an error: ggplot(dat_long) + geom_line(aes(x = factor (stage), y = val, colour = var)) #&gt; geom_path: Each group consists of only one observation. Do you need to #&gt; adjust the group aesthetic? Another common problem when the incorrect grouping is used is that you will see a jagged sawtooth pattern, as in Figure 8.7: ggplot(dat_long) + geom_line(aes(x = stage, y = val)) + geom_point(aes(x = stage, y = val, shape = var), size = 4) Figure 8.7: A sawtooth pattern indicates improper grouping This happens because there are multiple data points at each y location, and ggplot thinks they’re all in one group. The data points for each group are connected with a single line, leading to the sawtooth pattern. If any discrete variables are mapped to aesthetics like colour or linetype, they are automatically used as grouping variables. But if you want to use other variables for grouping (that aren’t mapped to an aesthetic), they should be used with group. Note When in doubt, if your line graph looks wrong, try explicitly specifying the grouping variable with group. It’s common for problems to occur with line graphs because ggplot is unsure of how the variables should be grouped. If your plot has points along with the lines, you can also map variables to properties of the points, such as shape and fill (Figure 8.8): ggplot(dat_long) + geom_line(aes(x = stage, y = val, shape = var)) + geom_point(aes(x = stage, y = val, shape = var), size = 4) # Make the points a little larger #&gt; Warning: Ignoring unknown aesthetics: shape ggplot(dat_long) + geom_line(aes(x = stage, y = val, fill = var)) + geom_point(aes(x = stage, y = val, fill = var), size = 4, shape = 21) # Also use a point with a color fill #&gt; Warning: Ignoring unknown aesthetics: fill Figure 8.8: Line graph with different shapes (left); With different colors (right) Sometimes points will overlap. In these cases, you may want to dodge them, which means their positions will be adjusted left and right (Figure 8.9). When doing so, you must also dodge the lines, or else only the points will move and they will be misaligned. You must also specify how far they should move when dodged: ggplot(dat_long) + geom_line(aes(x = stage, y = val, shape = var), position = position_dodge(0.2)) + # Dodge lines by 0.2 geom_point(aes(x = stage, y = val, fill = var), position = position_dodge(0.2), size = 4) # Dodge points by 0.2 #&gt; Warning: Ignoring unknown aesthetics: shape Figure 8.9: Dodging to avoid overlapping points 8.4 Changing the Appearance of Lines 8.4.1 Problem You want to change the appearance of the lines in a line graph. 8.4.2 Solution The type of line (solid, dashed, dotted, etc.) is set with linetype, the thickness (in mm) with size, and the color of the line with colour (or color). These properties can be set (as shown in Figure 8.10) by passing them values in the call to geom_line(): ggplot(dat) + geom_line(aes(x = stage, y = vo2), linetype = &quot;dashed&quot;, size = 1, colour = &quot;blue&quot;) Figure 8.10: Line graph with custom linetype, size, and colour If there is more than one line, setting the aesthetic properties will affect all of the lines. On the other hand, mapping variables to the properties, as we saw in Recipe 8.3, will result in each line looking different. The default colors aren’t the most appealing, so you may want to use a different palette, as shown in Figure 8.11, by using scale_colour_brewer() or scale_colour_manual(): ggplot(dat_long) + geom_line(aes(x = stage, y = val, colour = var)) + scale_colour_brewer(palette = &quot;Set1&quot;) Figure 8.11: Using a palette from RColorBrewer 8.4.3 Discussion To set a single constant color for all the lines, specify colour outside of aes(). The same works for size, linetype, and point shape (Figure 8.12). You may also have to specify the grouping variable: # If both lines have the same properties, you need to specify a variable to # use for grouping ggplot(dat_long) + geom_line(aes(x = stage, y = val, group = var), colour = &quot;darkgreen&quot;, size = 1.5) # Since supp is mapped to colour, it will automatically be used for grouping ggplot(dat_long) + geom_line(aes(x = stage, y = val, colour = var), linetype = &quot;dashed&quot;) + geom_point(aes(x = stage, y = val, colour = var),shape = 22, size = 3, fill = &quot;white&quot;) Figure 8.12: Line graph with constant size and color (left); With supp mapped to colour, and with points added (right) The range of different linetypes that is available can be seen in (Figure 8.13) Figure 8.13: The different types of linetype you can use. 8.5 Changing the Appearance of Points 8.5.1 Problem You want to change the appearance of the points in a line graph. 8.5.2 Solution In geom_point(), set the size, shape, colour, and/or fill outside of aes() (the result is shown in Figure 8.14): ggplot(dat) + geom_line(aes(x = stage, y = vo2)) + geom_point(aes(x = stage, y = vo2), size = 4, shape = 22, colour = &quot;darkred&quot;, fill = &quot;pink&quot;) Figure 8.14: Points with custom size, shape, color, and fill 8.5.3 Discussion The default shape for points is a solid circle, the default size is 2, and the default colour is black. The fill color is relevant only for some point shapes (numbered 21–25), which have separate outline and fill colors . The fill color is typically NA, or empty; you can fill it with white to get hollow-looking circles, as shown in Figure 8.15: ggplot(dat) + geom_line(aes(x = stage, y = vo2)) + geom_point(aes(x = stage, y = vo2), size = 4, shape = 21, fill = &quot;white&quot;) Figure 8.15: Points with a white fill There are plethora of point types that is availabe in R, which you can see below (Figure 8.16). Figure 8.16: Point types available in R. If the points and lines have different colors, you should specify the points after the lines, so that they are drawn on top. Otherwise, the lines will be drawn on top of the points. 8.6 Using Themes to Change Overall Appearance of Plot 8.6.1 Problem You want to use premade themes to control the overall plot appearance. 8.6.2 Solution There are many premade themes that are already included in ggplot2. The default ggplot2 theme is theme_grey(), but the examples below also showcase theme_bw(), theme_minimal(), and theme_classic(). To use a premade theme, add theme_bw() or another theme to your plot (Figure 8.17): library(gcookbook) # Load gcookbook for the heightweight data set # Create the base plot hw_plot &lt;- ggplot(heightweight, aes(x = ageYear, y = heightIn)) + geom_point() # Grey theme (the default) hw_plot + theme_grey() # Black-and-white theme hw_plot + theme_bw() # Minimal theme without background annotations hw_plot + theme_minimal() # Classic theme, with axis lines but no gridlines hw_plot + theme_classic() Figure 8.17: Scatter plot with theme_grey() (the default, top left); with theme_bw() (top right); with theme_minimal() (bottom left); with theme_classic() (bottom right) Another theme included in ggplot2 is theme_void(), which makes all plot elements blank and only shows your data (Figure 8.18. This is especially useful if you don’t want any default theme settings, and instead want a blank slate on which to choose your own theme elements. hw_plot + theme_void() Figure 8.18: Scatter plot with theme_void() 8.6.3 Discussion Some commonly used properties of theme elements in ggplot2 are those things that are controlled by theme(). Most of these things, like the title, legend, and axes, are outside the plot area, but some of them are inside the plot area, such as grid lines and the background coloring. Besides the themes included in ggplot2, it is also possible to create your own. You can set the base font family and size with either of the included themes (the default base font family is Helvetica, and the default size is 12): hw_plot + theme_grey(base_size = 16, base_family = &quot;Times&quot;) You can set the default theme for the current R session with theme_set(), although it’s generally not a good idea to set options globally because it may affect other plots that are unrelated to your current project: # Set default theme for current session theme_set(theme_bw()) # This will use theme_bw() hw_plot # Reset the default theme back to theme_grey() theme_set(theme_grey()) 8.7 Learning check From your learning check in 7.8, open up your practice_script.R. Import the Excel file data/treadmill_pt4_clean.xlsx, and the sheet Sheet1, and assign it to an object dat. See Recipe 5.2. Create another dataset, dat_summ, and create another variable called stage, where you create intervals of stage each of 3:30min intervals. See Recipe 6.5. Using the data dat_summ, remove the last 30s of data at each stage of VO2 testing. See Recipe 6.14. From step 4, keep the last 30s of data at each stage of VO2 testing. See Recipe 6.14. From step 5, find the mean of each 30s of data of each stage, across all variables. See Recipe 6.14. Make a line plot with with vo2 as the x axis, and vo2 as the y axis. See Recipe 8.1. "],
["your-assignment.html", "Chapter 9 Your Assignment", " Chapter 9 Your Assignment This assignment is designed to create a graph of lactate and heart rate against speed in the Incremental Treadmill Test. There are two things to note: With the graphs creates, export it and paste into your word assignment document. Copy the entire code below as an appendix in the word assignment document. The assignment is EASY!!! I am only asking you to copy and paste relevant recipes which you have learned, and edit relevant values in the function’s arguments. For example, when you see the value XXX, I am asking you to replace it with the relevant value. I am NOT going to ask you to create codes from scratch. I am not cruel. To do your assignment, follow these steps: Create a folder called se201_assignment on your desktop. Create a project called analysis inside the folder. See Reciple 4.2. Create a new R script called treadmill_analysis.R, paste the codes you see below, and save it. Paste you Excel data into the se201_assignment folder. Remember your treadmill_analysis.R and Excel files should be in the same folder. Task 1: Import data. Replace XXX with your Excel file’s name and appropriate sheet name. See Reciple 5.2. Task 2: Rename columns. Rename all columns to lower cases, without white spaces. See Reciple 6.1. Task 3: Maker characters to numeric. Replace XXX with the appropriate function to convert all columns apart from time from character to numbers. See Reciple 6.3. Task 4: Find the average 30s value (between 2:30min to 3:00min) per stage for all variables. Replace XXX with the appropriate values. See Reciple 6.14. Task 5: Combine two tables. Merge the average data from Task 4 with the object called dat_stage along the common header. Replace XXX with the appropriate values. See Reciple 6.15. Task 6: Make a lactate graph. Plot a line graph of speed as the x axis, and lactacte as the y axis, with the line colour blue. Give the graph a succinct title. Replace XXX with the appropriate values. See Reciples 8.1, 8.4. Save the plot. Task 7: Make a lactate graph. Plot a line graph of speed as the x axis, and hr as the y axis, with the line colour blue. Give the graph a succinct title. Replace XXX with the appropriate values. See Reciples 8.1, 8.4. Save the plot. ## --------------------------- ## ## ## Author: Bernard Liew ## ## Date Created: 2020-09-02 ## ## ## --------------------------- ## ## Notes: ## ## ## --------------------------- ## --------------------------- ## load up the packages we will need if (!require(&quot;pacman&quot;)) install.packages(&quot;pacman&quot;) pacman::p_load(tidyverse, # All purpose wrangling for dataframes lubridate, # Time tibbletime, openxlsx) # writing excel documents ## Custom function to get interection between two lines ## To get Lactate and Anaerobic Threshold values ## Ignore the complexity, highlight between Start and End, Run -------------- ## Start ---------------- curve_intersect &lt;- function (curve1, curve2, empirical = TRUE, domain = NULL) { if (!empirical &amp; missing(domain)) { stop(&quot;&#39;domain&#39; must be provided with non-empirical curves&quot;) } if (!empirical &amp; (length(domain) != 2 | !is.numeric(domain))) { stop(&quot;&#39;domain&#39; must be a two-value numeric vector, like c(0, 10)&quot;) } if (empirical) { curve1_f &lt;- approxfun(curve1$x, curve1$y, rule = 2) curve2_f &lt;- approxfun(curve2$x, curve2$y, rule = 2) point_x &lt;- uniroot(function(x) curve1_f(x) - curve2_f(x), c(min(curve1$x), max(curve1$x)))$root point_y &lt;- curve2_f(point_x) } else { point_x &lt;- uniroot(function(x) curve1(x) - curve2(x), domain)$root point_y &lt;- curve2(point_x) } return(list(x = point_x, y = point_y)) } ## End ---------------- ## Import data (Task 1) dat_vo2 &lt;- read.xlsx (xlsxFile = &quot;XXX.xlsx&quot;, sheet = &quot;XXX&quot;) dat_stage &lt;- read.xlsx (xlsxFile = &quot;XXX.xlsx&quot;, sheet = &quot;XXX&quot;) ## Analyze VO2 data ---------------------------------------------------------------------- ### Rename column names (Task 2) new_names &lt;- c() colnames (dat_vo2) &lt;- new_names ### Remove first row dat_vo2 &lt;- dat_vo2 %&gt;% slice (-(1)) ### Convert column type (Task 3) dat_vo2 &lt;- dat_vo2 %&gt;% mutate (bf = XXX (bf), vo2_norm = XXX(vo2_norm), rer = XXX(rer), vo2 = XXX(vo2), vco2 = XXX(vco2), ve = XXX(ve), hr = XXX(hr)) %&gt;% # Convert time to seconds mutate (time = time %&gt;% str_squish() %&gt;% ms() %&gt;% as.period(unit = &quot;sec&quot;) %&gt;% as.numeric ()) ### Create a &quot;stage&quot; variable dat_vo2 &lt;- dat_vo2 %&gt;% mutate (stage = cut_interval(time, length = 210, labels = FALSE)) ### Calculate average 30s data per stage (Task 4) dat_vo2_summ &lt;- dat_vo2 %&gt;% group_by(XXX) %&gt;% # for each group slice(XXX:XXX) %&gt;% # keep time 2:30 - 3min per stage summarise_at (vars(bf:hr), mean) ### Combine stage and average data (Task 5) dat_vo2_comb &lt;- dat_vo2_summ %&gt;% inner_join(dat_stage, by = &quot;XXX&quot;) ### Plot #### Lactate (Task 6) f &lt;- ggplot (dat_vo2_comb) + geom_line (aes (x = XXX, y = XXX), colour = &quot;XXX&quot;, size = 1.5) + labs (x = &quot;Speed (km/h)&quot;, y = &quot;Lactate (mmol)&quot;) + theme_bw() + labs (title = &quot;XXX&quot;) + theme(axis.text.x = element_text(size = 12), axis.text.y = element_text(size = 12), axis.title.x = element_text(size = 16), axis.title.y = element_text(size = 16)) ggsave(filename = &quot;lactate.png&quot;, plot = f, # the name of the image object you created above. width = 8, height = 8, unit = &quot;cm&quot;, dpi = 300) #### Heart rate (Task 7) f &lt;- ggplot (dat_vo2_comb) + geom_line (aes (x = XXX, y = XXX), colour = &quot;XXX&quot;, size = 1.5) + labs (x = &quot;Speed (km/h)&quot;, y = &quot;Lactate (mmol)&quot;) + theme_bw() + labs (title = &quot;XXX&quot;) + theme(axis.text.x = element_text(size = 12), axis.text.y = element_text(size = 12), axis.title.x = element_text(size = 16), axis.title.y = element_text(size = 16)) ggsave(filename = &quot;heartrate.png&quot;, plot = f, # the name of the image object you created above. width = 8, height = 8, unit = &quot;cm&quot;, dpi = 300) ## Bonus Codes to help you ------------------------------------------------- ### Get VO2 max , VO2 max relative rolling_mean6 &lt;- rollify(mean, window = 6) raw_roll &lt;- dat_vo2 %&gt;% arrange (desc (time)) %&gt;% summarise_at (vars(bf:hr), rolling_mean6) %&gt;% summarise_at(vars(bf:hr), max, na.rm = TRUE) ### Get Lactate and Anaerobic Thresold m &lt;- loess (lactate ~ speed, data = dat_vo2_comb) min.speed &lt;- ceiling (min (dat_vo2_comb$speed)) max.speed &lt;- floor (max (dat_vo2_comb$speed)) n_points &lt;- 100 new_lac &lt;- data.frame (speed = seq (min.speed, max.speed, length.out = n_points)) new_lac$y &lt;- predict (m, newdata = new_lac) colnames(new_lac)[1] &lt;- &quot;x&quot; #### Threshold values lactate_thres &lt;- data.frame (x = seq (min.speed, max.speed, length.out = n_points), y = 2) anaerobic_thres &lt;- data.frame (x = seq (min.speed, max.speed, length.out = n_points), y = 4) #### Speed at thresold speed_at_lac_thres &lt;- curve_intersect(new_lac, lactate_thres)$x speed_at_ane_thres &lt;- curve_intersect(new_lac, anaerobic_thres)$x ### Get HR at thresholds m &lt;- loess (hr ~ speed, data = dat_vo2_comb) new_hr &lt;- data.frame (speed = seq (min.speed, max.speed, length.out = n_points)) new_hr$y &lt;- predict (m, newdata = new_hr) colnames(new_hr)[1] &lt;- &quot;x&quot; hr_at_lac_thres &lt;- new_hr[which.min(abs(new_hr$x -speed_at_lac_thres)), &quot;y&quot;] %&gt;% round (0) hr_at_ane_thres &lt;- new_hr[which.min(abs(new_hr$x -speed_at_ane_thres)), &quot;y&quot;] %&gt;% round pi &lt;- data.frame(Variable = c(&quot;Lactate Threshold&quot;, &quot;Anaerobic Threshold&quot;), Speed = c(speed_at_lac_thres, speed_at_ane_thres ), HR = c(hr_at_lac_thres, hr_at_ane_thres)) pi df_plot &lt;- data.frame(speed = new_lac$x, lactate = new_lac$y, hr = new_hr$y, speed_lac = speed_at_lac_thres, speed_ane = speed_at_ane_thres) %&gt;% pivot_longer(cols = lactate:hr, names_to = &quot;var&quot;, values_to = &quot;val&quot;) ggplot (df_plot) + geom_line (aes (x = speed, y = val)) + geom_vline(xintercept = speed_at_lac_thres, color = &quot;blue&quot;, linetype = &quot;dashed&quot;) + geom_vline(xintercept = speed_at_ane_thres, color = &quot;red&quot;, linetype = &quot;dashed&quot;) + facet_wrap(~var, ncol = 2, scales = &quot;free&quot;) + labs (x = &quot;Speed&quot;, y = &quot;Values&quot;) + theme_bw() + labs (title = &quot;Plot of Treadmill test&quot;) + theme(axis.text.x = element_text(size = 12), axis.text.y = element_text(size = 12), axis.title.x = element_text(size = 16), axis.title.y = element_text(size = 16)) "]
]
