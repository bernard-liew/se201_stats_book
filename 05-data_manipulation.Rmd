# Data manipulation{#WRANGLE}

## Download and load packages {-}

```{r, message=FALSE, warning=FALSE}
if (!require("pacman")) install.packages("pacman")
pacman::p_load(tidyverse, # All purpose wrangling for dataframes
               openxlsx,# writing excel documents
               lubridate,# date-time 
               tibbletime) # moving average for vo2

```



## Import data {-}

```{r, echo = FALSE}
vembedr::embed_url("https://youtu.be/ficAKoksgFI")
```

Let's load the files from the `data` folder into the work space again. 

```{r message=FALSE, warning=FALSE}


dat_fms <-  read.xlsx (xlsxFile = "data/fms_pt3.xlsx",
                   sheet = "Sheet1")

dat_fms_grp <- read.xlsx (xlsxFile = "data/simFMS.xlsx",
                   sheet = "FMS")

dat_vo2 <-  read.xlsx (xlsxFile = "data/treadmill_pt4.xlsx",
                   sheet = "raw")

dat_vo2_stage <-  read.xlsx (xlsxFile = "data/treadmill_pt4.xlsx",
                   sheet = "stage")

bad_leg_accl <-  read.xlsx (xlsxFile = "data/rightleg_imu.xlsx")

good_leg_accl <-  read.xlsx (xlsxFile = "data/leftleg_imu.xlsx")
```

### Let us see the data {-}

#### dat_fms table 

This is a table representing a single subject's FMS test scores

```{r, echo = FALSE}
dat_fms %>%
  knitr::kable ()
```

#### dat_fms_grp

This is a table representing a team's total FMS test score for each task

```{r, echo = FALSE}
dat_fms_grp %>%
  knitr::kable ()%>%
  kableExtra::scroll_box(width = "100%", height = "500px")
```


#### dat_vo2

This is a table representing a single subject's raw VO2 results during incremental treadmill running

```{r, echo = FALSE}
dat_vo2 %>%
  knitr::kable () %>%
  kableExtra::scroll_box(width = "100%", height = "500px")
```
#### dat_vo2_stage

This is a table representing a single subject's lactate values during incremental treadmill running

```{r, echo = FALSE}
dat_vo2_stage %>%
  knitr::kable () %>%
  kableExtra::scroll_box(width = "100%", height = "500px")
```

#### Drop jump imu

Bad leg

This is a table representing a single subject's single leg drop jump imu data.

```{r, echo = FALSE}
bad_leg_accl %>%
  knitr::kable () %>%
  kableExtra::scroll_box(width = "100%", height = "500px")
```

Good leg

```{r, echo = FALSE}
good_leg_accl %>%
  knitr::kable () %>%
  kableExtra::scroll_box(width = "100%", height = "500px")
```


## Tidy data {#WRANGLE-TIDY-DATA}

```{r, echo = FALSE}
vembedr::embed_url("https://youtu.be/LKftcxMdqm8")
```


You can represent the same underlying data in multiple ways. The example below shows the same data organised in four different ways. This dataset is **not the data you loaded**, but rather came with the `tidyverse` package. Each dataset shows the same values of four variables *country*, *year*, *population*, and *cases*, but each dataset organises the values in a different way.

```{r}
table1
table2
table3

# Spread across two tables
table4a  # cases
table4b  # population
```

These are all representations of the same underlying data, but they are not equally easy to use. One dataset, the tidy dataset, will be much easier to work with. 

There are three interrelated rules which make a dataset tidy:

1.  Each variable must have its own column.
1.  Each observation must have its own row.
1.  Each value must have its own cell.

Figure \@ref(fig:tidy-structure) shows the rules visually.

```{r tidy-structure, echo = FALSE, out.width = "100%", fig.cap = "Following three rules makes a dataset tidy: variables are in columns, observations are in rows, and values are in cells."}
knitr::include_graphics("images/chapter-5/tidy-1.png")
```

These three rules are interrelated because it's impossible to only satisfy two of the three. 

In this example, only `table1` is tidy. It's the only representation where each column is a variable.

Why ensure that your data is tidy? There are two main advantages:

1.  There's a general advantage to picking one consistent way of storing
    data. If you have a consistent data structure, it's easier to learn the
    tools that work with it because they have an underlying uniformity.
    
1.  There's a specific advantage to placing variables in columns because
    most of R functions work with data in the tidy format. That makes transforming 
    tidy data feel particularly natural.
    
The principles of tidy data seem so obvious that you might wonder if you'll ever encounter a dataset that isn't tidy. Unfortunately, however, most data that you will encounter will be untidy. There are two main reasons:

1.  Most people aren't familiar with the principles of tidy data, and it's hard
    to derive them yourself unless you spend a _lot_ of time working with data.
    
2.  Data is often organised to facilitate some use other than analysis. For 
    example, data is often organised to make entry as easy as possible.
    
This means for most real analyses, you'll need to do some tidying. The first step is always to figure out what the variables and observations are. Sometimes this is easy; other times you'll need to consult with the people who originally generated the data. 
The second step is to resolve one of two common problems:

1. One variable might be spread across multiple columns.

2. One observation might be scattered across multiple rows.

Typically a dataset will only suffer from one of these problems; it'll only suffer from both if you're really unlucky! To fix these problems, you'll need the two most important functions in tidyr: `pivot_wider()` in Recipe \@ref(WRANGLE-SPREAD) and `pivot_longer()` in Recipe \@ref(WRANGLE-GATHER) below.


## Renaming variables {#WRANGLE-RENAME-VARIABLES}

```{r, echo = FALSE}
vembedr::embed_url("https://youtu.be/JB4Ex9oFZi0")
```

### Problem

The current column names in the `dat_vo2` dataset is ugly, and you like to abbreviate it. I dislike excessive usage of capitalisations. It is a lot of effort to type.

```{r}
# This prints the current column names

colnames (dat_vo2) 

```


### Solution

Create a vector of 8 new names that you can give to the data. The order of new names must be identical to the order of the old names from left to right.

```{r }
# New names. Notice the commas and be pedantic about spacing

new_names <- c("time", "bf", "vo2_norm", "rer", "vo2", "vco2", "ve", "hr")

# Give the new names to the old names

colnames (dat_vo2)  <- new_names

# This prints the new column names

colnames (dat_vo2)  

```

## Selecting rows {#WRANGLE-SLICE}

```{r, echo = FALSE}
vembedr::embed_url("https://youtu.be/-VR2j-dNFY0")
```

### Problem

You want to remove a specific row  or a range of rows. See also Recipe \@ref(WRANGLE-FILTER).

### Solution

To keep or remove rows based on the row numbers, use `slice ()`, `slice_head()`, or `slice_tail()`. In `slice ()`, when you want to keep the row, add that row number. If you want to remove that row number, use a minus sign, `-`, before the number. If you want to keep or remove a range of numbers, add `start:end` inside `slice()`. In `slice_tail ()` and `slice_head()`, you can keep the bottom, and top, *n* number of rows, respectively, by adding `n = 3` for example inside `slice_tail()` or `slice_head()`.

```{r }
# This keeps only the second row

vo2_slice <- dat_vo2 %>% 
  slice (2) 
```

```{r, echo = FALSE}
vo2_slice %>%
  head() %>%
  knitr::kable (digits = 2)
```

```{r }
# This removes the second row
vo2_slice <- dat_vo2 %>% 
  slice (-2) 
```

```{r, echo = FALSE}
vo2_slice %>%
  head() %>%
  knitr::kable (digits = 2)
```

```{r }
# This removes the second and third rows
vo2_slice <- dat_vo2 %>% 
  slice (-(2:3))
```

```{r, echo = FALSE}
vo2_slice %>%
  head() %>%
  knitr::kable (digits = 2)
```

```{r }
# This keeps the top six rows

vo2_slice <- dat_vo2 %>% 
  slice_head (n = 6) 
```

```{r, echo = FALSE}
vo2_slice %>%
  head() %>%
  knitr::kable (digits = 2)
```

```{r }
# This keeps the bottom six rows

vo2_slice <- dat_vo2 %>% 
  slice_tail (n = 6) 
```

```{r, echo = FALSE}
vo2_slice %>%
  head() %>%
  knitr::kable (digits = 2)
```


```{r }
# This removes the first row, and replaces the old data in object dat_vo2

dat_vo2 <- dat_vo2 %>% 
  slice (-(1))

```


## Selecting columns {#WRANGLE-SELECT}

```{r, echo = FALSE}
vembedr::embed_url("https://youtu.be/-VR2j-dNFY0")
```

### Problem

You want to keep or remove a specific column or a range of columns. 

### Solution

To keep based on the column names, use the `select ()` function. When keying in the name of the column variables you want to keep, you do not really need to use the `""`. This means, you can type the names you want like the following: `select(time_s, mx_microT)`. In the example below, I used `""` to surround the variable names. I did this because as previously mentioned in \@ref(INPUT-FILE), the symbol `/` has a special, **irritating** meaning in R. So, avoid having such symbols anyway in your files, but for now, I have shown you how to overcome this problem.

```{r }

# This selects the vertical acceleration signal of the IMU of the bad leg

bad_vertical_accl <- bad_leg_accl %>%
  select ("highg_az_m/s/s")
```

```{r, echo = FALSE}
bad_vertical_accl %>%
  head() %>%
  knitr::kable (digits = 2)
```


```{r }

# This selects the vertical acceleration signal of the IMU of the good leg

good_vertical_accl <- good_leg_accl %>%
  select ("highg_az_m/s/s")
```

```{r, echo = FALSE}
good_vertical_accl %>%
  head() %>%
  knitr::kable (digits = 2)
```

## Convert characters to numeric {#WRANGLE-CHARACTER-2-NUMERIC}

```{r, echo = FALSE}
vembedr::embed_url("https://youtu.be/j1J63-ePZd8")
```

### Problem

The raw Vo2 treadmill dataset contains predominantly numbers, meaning it is numeric in nature. See also Section \@ref(BASIC-TYPES). But let us see the type of data that was imported. The `str()` function provides us with some summary information about the dataframe.

```{r}
str(dat_vo2)
```

What you will see is something like this. For the variable `bf`, you will see `$ bf      : chr  "37" "58" "30" "34" ...`. `chr` after the colon. This indicates that this variable is a character (`chr`). In R language, a character is anything from a letter, e.g. `a`, to a word, e.g. `word`, to even a phrase of sentence, e.g. `i hate biomechanics`. A character is always enclosed inside a `""`. 

Why is R so "stupid", that it cannot differentiate numbers from words!! Well it is not that R is stupid, but it is that in our original data, each column have both words and numbers (Figure \@ref(fig:col-class)). It is our fault that the data was untidy.

This was touched on in in Section \@ref(WRANGLE-TIDY-DATA), about why this is bad data formatting. In brief, each column should be made up of one type of data. If it is numbers, make it all numbers; characters, all characters. If you have mix, the default is that R treats that column as all characters. 

The reason why you should not leave numbers as characters is that you cannot do math on it. You cannot add `apples` and `orange` can you?


```{r col-class, echo = FALSE, out.width = "100%", fig.cap = "The type of data for each class as it was imported."}
knitr::include_graphics("images/chapter-5/dat_vo2_column_class.png")
```


### Solution

Use the `mutate()` function and the `as.numeric` function. 

```{r}
# Make all variables from bf to hr numeric, and replace the current data

dat_vo2 <-  dat_vo2 %>%
  mutate (bf = as.numeric(bf),
          vo2_norm = as.numeric(vo2_norm),
          rer = as.numeric(rer),
          vo2 = as.numeric(vo2),
          vco2 = as.numeric(vco2),
          ve = as.numeric(ve),
          hr = as.numeric(hr))

# Recheck the type of each column 

str(dat_vo2)

```

## Convert characters to date and time {#WRANGLE-CHARACTER-2-TIME}

```{r, echo = FALSE}
vembedr::embed_url("https://youtu.be/rBIq-n-RZxI")
```

### Problem

The raw `dat_vo2` data `time` variable is a character with ugly white spaces. When you use the `str()` function on the time column using the `$` symbol, you can see that each value looks like `"  00:05 "`. It means that is a blank before and after the `00:05`. 

```{r}
str(dat_vo2$time)
```

### Solution

First, let me create a carbon copy of the data `dat_vo2`, so that I can modify the original data, and keep the carbon copy for explanation and illustration.

```{r}
dat_vo2_copy <- dat_vo2 
```


Use the `mutate()` function and the `as.numeric` function. You will learn the `mutate ()` function more in Recipe \@ref(WRANGLE-NEW-VARIABLES).

```{r}

# 4 in 1 processing

dat_vo2 <- dat_vo2 %>%
  mutate (time = time %>% 
            str_squish() %>% # function strips any whitespaces
            ms() %>% # convert to minutes and seconds
            as.period(unit = "sec") %>% # converts entirely to seconds
            as.numeric ()) # strips the S symbol to make it a number

```

```{r, echo = FALSE}
dat_vo2 %>%
  head()%>%
  knitr::kable (digits = 2)
```

### Discussion

Notice in the function above, I chained a series of steps together, using the pipe, `%>%`, function. Alternatively, I could do it in separate steps, and we can take a look at how each step changed the appearance of the `time` variable. Let me illustrate each step using the carbon copy data `dat_vo2_copy`.


```{r, echo = FALSE}
vembedr::embed_url("https://youtu.be/imDxCPMgXfE")
```


```{r }
# First, removes whitespaces around the time variable
time_mutate <- dat_vo2_copy %>%
  mutate (time = time %>% 
                 str_squish()) 
```

```{r, echo = FALSE}
time_mutate %>%
  head()%>%
  knitr::kable (digits = 2)
```

```{r }
# Second, convert to minutes and seconds

time_mutate <- dat_vo2_copy %>%
  mutate (time = time %>% 
                 str_squish()%>%  
                 ms())

```

```{r, echo = FALSE}
time_mutate %>%
  tail () %>%
  knitr::kable (digits = 2)
```

```{r }
# Third, converts entirely to seconds

time_mutate <- dat_vo2_copy %>%
  mutate (time = time %>% 
                 str_squish()%>%  
                 ms() %>%
                 as.period(unit = "sec")) 
```

```{r, echo = FALSE}
time_mutate %>%
  tail () %>%
  knitr::kable (digits = 2)
```

```{r }
# Fourth, strips the S symbol to make it a number, and assign it to object

time_mutate <- dat_vo2_copy %>%
  mutate (time = time %>% 
                 str_squish()%>%  
                 ms() %>%
                 as.period(unit = "sec") %>% 
                 as.numeric ())

```

```{r, echo = FALSE}
time_mutate %>%
  tail () %>%
  knitr::kable (digits = 2)
```


## Split Numeric Variable into Categories {#WRANGLE-NUMERIC-CATEGORY}

```{r, echo = FALSE}
vembedr::embed_url("https://youtu.be/TYBTXk95doo")
```

### Problem

Remember, each stage in VO2 testing is 3:30min (210sec) long, and you collected data in 5sec intervals. You want to split the `time` variable of the `dat_vo2` dataset into chunks of 210 sec, and create a new variable called `stage`. You will learn the `mutate ()` function more in Recipe \@ref(WRANGLE-NEW-VARIABLES). I will not explain the `cut_interval` function, other than to say that the `length` argument is used to specify the range of evenly spaced values to categorize over.

### Solution

```{r}
dat_vo2 <- dat_vo2 %>%
  mutate (stage = cut_interval(time, length = 210, labels = FALSE))

```

```{r, echo = FALSE}
dat_vo2 %>%
  head()%>%
  knitr::kable (digits = 2)
```

### Discussion

Why chunks of 210 sec? Vo2 data analysis, requires you to find the average values of the last 30s of each treadmill testing stage. Based on your Autumn School lessons, recall that each stage is 3 min 30 sec long or 210 sec. When doing data analysis, there is an amount of pre-planning on how to get the desired end product. There is no magic pill, the more analysis you do, the more short cuts you know.
