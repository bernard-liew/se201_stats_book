[["WRANGLE.html", "Chapter 6 Data manipulation Download and load packages Import data 6.1 Tidy data 6.2 Renaming variables 6.3 Selecting rows and columns 6.4 Convert characters to numeric 6.5 Convert characters to date and time 6.6 Split Numeric Variable into Categories 6.7 Spreading 6.8 Gathering 6.9 Rename values of a variable 6.10 Creating factors 6.11 Making a new variable 6.12 Filtering 6.13 Global summary 6.14 Group-by summary 6.15 Merge two tables together 6.16 Learning check", " Chapter 6 Data manipulation Download and load packages if (!require(&quot;pacman&quot;)) install.packages(&quot;pacman&quot;) pacman::p_load(tidyverse, # All purpose wrangling for dataframes openxlsx,# writing excel documents lubridate,# date-time tibbletime) # moving average for vo2 Import data Lets load the 3 files from data folder into the workspace again. File one contains the FMS data, another the VO2 raw data from the treadmill test, and lastly the lactate data from the treadmill test. dat_fms &lt;- read.xlsx (xlsxFile = &quot;data/fms_pt3.xlsx&quot;, sheet = &quot;Sheet1&quot;) dat_vo2 &lt;- read.xlsx (xlsxFile = &quot;data/treadmill_pt4.xlsx&quot;, sheet = &quot;raw&quot;) dat_vo2_stage &lt;- read.xlsx (xlsxFile = &quot;data/treadmill_pt4.xlsx&quot;, sheet = &quot;stage&quot;) 6.1 Tidy data You can represent the same underlying data in multiple ways. The example below shows the same data organised in four different ways. This dataset is not the data you loaded, but rather came with the tidyverse package. Each dataset shows the same values of four variables country, year, population, and cases, but each dataset organises the values in a different way. table1 ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 table2 ## # A tibble: 12 x 4 ## country year type count ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 cases 745 ## 2 Afghanistan 1999 population 19987071 ## 3 Afghanistan 2000 cases 2666 ## 4 Afghanistan 2000 population 20595360 ## 5 Brazil 1999 cases 37737 ## 6 Brazil 1999 population 172006362 ## 7 Brazil 2000 cases 80488 ## 8 Brazil 2000 population 174504898 ## 9 China 1999 cases 212258 ## 10 China 1999 population 1272915272 ## 11 China 2000 cases 213766 ## 12 China 2000 population 1280428583 table3 ## # A tibble: 6 x 3 ## country year rate ## * &lt;chr&gt; &lt;int&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 # Spread across two tables table4a # cases ## # A tibble: 3 x 3 ## country `1999` `2000` ## * &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 745 2666 ## 2 Brazil 37737 80488 ## 3 China 212258 213766 table4b # population ## # A tibble: 3 x 3 ## country `1999` `2000` ## * &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 19987071 20595360 ## 2 Brazil 172006362 174504898 ## 3 China 1272915272 1280428583 These are all representations of the same underlying data, but they are not equally easy to use. One dataset, the tidy dataset, will be much easier to work with. There are three interrelated rules which make a dataset tidy: Each variable must have its own column. Each observation must have its own row. Each value must have its own cell. Figure 6.1 shows the rules visually. Figure 6.1: Following three rules makes a dataset tidy: variables are in columns, observations are in rows, and values are in cells. These three rules are interrelated because its impossible to only satisfy two of the three. In this example, only table1 is tidy. Its the only representation where each column is a variable. Why ensure that your data is tidy? There are two main advantages: Theres a general advantage to picking one consistent way of storing data. If you have a consistent data structure, its easier to learn the tools that work with it because they have an underlying uniformity. Theres a specific advantage to placing variables in columns because most of R functions work with data in the tidy format. That makes transforming tidy data feel particularly natural. The principles of tidy data seem so obvious that you might wonder if youll ever encounter a dataset that isnt tidy. Unfortunately, however, most data that you will encounter will be untidy. There are two main reasons: Most people arent familiar with the principles of tidy data, and its hard to derive them yourself unless you spend a lot of time working with data. Data is often organised to facilitate some use other than analysis. For example, data is often organised to make entry as easy as possible. This means for most real analyses, youll need to do some tidying. The first step is always to figure out what the variables and observations are. Sometimes this is easy; other times youll need to consult with the people who originally generated the data. The second step is to resolve one of two common problems: One variable might be spread across multiple columns. One observation might be scattered across multiple rows. Typically a dataset will only suffer from one of these problems; itll only suffer from both if youre really unlucky! To fix these problems, youll need the two most important functions in tidyr: pivot_wider() in Recipe 6.7 and pivot_longer() in Recipe 6.8 below. 6.2 Renaming variables 6.2.1 Problem The current column names in the dat_vo2 dataset is ugly, and you like to abbreviate it. I dislike excessive usage of capitalisations. It is a lot of effort to type. # This prints the current column names colnames (dat_vo2) ## [1] &quot;Time&quot; &quot;BF&quot; &quot;VO2/kg&quot; &quot;RER&quot; &quot;V&#39;O2&quot; &quot;V&#39;CO2&quot; &quot;V&#39;E&quot; &quot;HR&quot; 6.2.2 Solution Create a vector of 8 new names that you can give to the data. The order of new names must be identical to the order of the old names from left to right. # New names. Notice the commas and be pedantic about spacing new_names &lt;- c(&quot;time&quot;, &quot;bf&quot;, &quot;vo2_norm&quot;, &quot;rer&quot;, &quot;vo2&quot;, &quot;vco2&quot;, &quot;ve&quot;, &quot;hr&quot;) # Give the new names to the old names colnames (dat_vo2) &lt;- new_names # This prints the new column names colnames (dat_vo2) ## [1] &quot;time&quot; &quot;bf&quot; &quot;vo2_norm&quot; &quot;rer&quot; &quot;vo2&quot; &quot;vco2&quot; &quot;ve&quot; ## [8] &quot;hr&quot; 6.3 Selecting rows and columns 6.3.1 Problem You want to remove a specific row or a range of rows, and remove a specific column or a range of columns. See also Recipe 6.12. 6.3.2 Solution To keep or remove rows based on the row numbers, use slice (), slice_head(), or slice_tail(). In slice (), when you want to keep the row, add that row number. If you want to remove that row number, use a minus sign, -, before the number. If you want to keep or remove a range of numbers, add start:end inside slice(). In slice_tail () and slice_head(), you can keep the bottom, and top, n number of rows, respectively, by adding n = 3 for example inside slice_tail() or slice_head(). To keep based on the column names, use the select () function. # This keeps only the second row vo2_slice &lt;- dat_vo2 %&gt;% slice (2) time bf vo2_norm rer vo2 vco2 ve hr 00:05 37 21.4 0.93 1371 1272 46 119 # This removes the second row vo2_slice &lt;- dat_vo2 %&gt;% slice (-2) time bf vo2_norm rer vo2 vco2 ve hr min 1/min ml/ min/kg ml/min ml/min L/min bpm 00:10 58 2.5 0.84 159 133 12 120 00:15 30 23.5 0.74 1506 1110 35 121 00:20 34 22.4 0.86 1437 1229 43 123 00:25 23 15.6 0.73 1004 735 22 124 00:30 27 30.5 0.76 1960 1489 48 124 # This removes the second and third rows vo2_slice &lt;- dat_vo2 %&gt;% slice (-(2:3)) time bf vo2_norm rer vo2 vco2 ve hr min 1/min ml/ min/kg ml/min ml/min L/min bpm 00:15 30 23.5 0.74 1506 1110 35 121 00:20 34 22.4 0.86 1437 1229 43 123 00:25 23 15.6 0.73 1004 735 22 124 00:30 27 30.5 0.76 1960 1489 48 124 00:35 39 23.3 0.73 1499 1092 38 124 # This keeps the top six rows vo2_slice &lt;- dat_vo2 %&gt;% slice_head (n = 6) time bf vo2_norm rer vo2 vco2 ve hr min 1/min ml/ min/kg ml/min ml/min L/min bpm 00:05 37 21.4 0.93 1371 1272 46 119 00:10 58 2.5 0.84 159 133 12 120 00:15 30 23.5 0.74 1506 1110 35 121 00:20 34 22.4 0.86 1437 1229 43 123 00:25 23 15.6 0.73 1004 735 22 124 # This keeps the bottom six rows vo2_slice &lt;- dat_vo2 %&gt;% slice_tail (n = 6) time bf vo2_norm rer vo2 vco2 ve hr 27:05 55 45.3125 1.0689655172413792 2900 3100 112 194 27:10 57 45.328125 1.0341261633919339 2901 3000 111 195 27:15 52 44.609375 1.063047285464098 2855 3035 111 194 27:20 59 46.5 1.0416666666666667 2976 3100 112 197 27:25 60 45.140625 1.0678435444790586 2889 3085 113 196 27:30 61 46 1.0506114130434783 2944 3093 114 195 # This selects the first, second, and fourth column, and discards the rest vo2_slice &lt;- dat_vo2 %&gt;% dplyr::select (time, bf, rer) time bf rer min 1/min 00:05 37 0.93 00:10 58 0.84 00:15 30 0.74 00:20 34 0.86 00:25 23 0.73 # This removes the first row, and replaces the old data in object dat_vo2 dat_vo2 &lt;- dat_vo2 %&gt;% slice (-(1)) 6.4 Convert characters to numeric 6.4.1 Problem The raw Vo2 treadmill dataset contains predominantly numbers, meaning it is numeric in nature. See also Section 3.4.1. But let us see the type of data that was imported. The str() function provides us with some summary information about the dataframe. str(dat_vo2) ## &#39;data.frame&#39;: 330 obs. of 8 variables: ## $ time : chr &quot; 00:05 &quot; &quot; 00:10 &quot; &quot; 00:15 &quot; &quot; 00:20 &quot; ... ## $ bf : chr &quot;37&quot; &quot;58&quot; &quot;30&quot; &quot;34&quot; ... ## $ vo2_norm: chr &quot;21.4&quot; &quot;2.5&quot; &quot;23.5&quot; &quot;22.4&quot; ... ## $ rer : chr &quot;0.93&quot; &quot;0.84&quot; &quot;0.74&quot; &quot;0.86&quot; ... ## $ vo2 : chr &quot;1371&quot; &quot;159&quot; &quot;1506&quot; &quot;1437&quot; ... ## $ vco2 : chr &quot;1272&quot; &quot;133&quot; &quot;1110&quot; &quot;1229&quot; ... ## $ ve : chr &quot;46&quot; &quot;12&quot; &quot;35&quot; &quot;43&quot; ... ## $ hr : chr &quot;119&quot; &quot;120&quot; &quot;121&quot; &quot;123&quot; ... What you will see is something like this. For the variable bf, you will see $ bf : chr \"37\" \"58\" \"30\" \"34\" .... chr after the colon. This indicates that this variable is a character (chr). In R language, a character is anything from a letter, e.g. a, to a word, e.g. word, to even a phrase of sentence, e.g. i hate biomechanics. A character is always enclosed inside a \"\". Why is R so stupid, that it cannot differentiate numbers from words!! Well it is not that R is stupid, but it is that in our original data, each column have both words and numbers (Figure 6.2). It is our fault that the data was untidy. This was touched on in in Section 6.1, about why this is bad data formatting. In brief, each column should be made up of one type of data. If it is numbers, make it all numbers; characters, all characters. If you have mix, the default is that R treats that column as all characters. The reason why you should not leave numbers as characters is that you cannot do math on it. You cannot add apples and orange can you? Figure 6.2: The type of data for each class as it was imported. 6.4.2 Solution Use the mutate() function and the as.numeric function. # Make all variables from bf to hr numeric, and replace the current data dat_vo2 &lt;- dat_vo2 %&gt;% mutate (bf = as.numeric(bf), vo2_norm = as.numeric(vo2_norm), rer = as.numeric(rer), vo2 = as.numeric(vo2), vco2 = as.numeric(vco2), ve = as.numeric(ve), hr = as.numeric(hr)) # Recheck the type of each column str(dat_vo2) ## &#39;data.frame&#39;: 330 obs. of 8 variables: ## $ time : chr &quot; 00:05 &quot; &quot; 00:10 &quot; &quot; 00:15 &quot; &quot; 00:20 &quot; ... ## $ bf : num 37 58 30 34 23 27 39 34 26 27 ... ## $ vo2_norm: num 21.4 2.5 23.5 22.4 15.6 30.5 23.3 29.6 31.9 29.4 ... ## $ rer : num 0.93 0.84 0.74 0.86 0.73 0.76 0.73 0.75 0.8 0.8 ... ## $ vo2 : num 1371 159 1506 1437 1004 ... ## $ vco2 : num 1272 133 1110 1229 735 ... ## $ ve : num 46 12 35 43 22 48 38 49 53 49 ... ## $ hr : num 119 120 121 123 124 124 124 124 124 125 ... 6.5 Convert characters to date and time 6.5.1 Problem The raw dat_vo2 data time variable is a character with ugly white spaces. When you use the str() function on the time column using the $ symbol, you can see that each value looks like \" 00:05 \". It means that is a blank before and after the 00:05. str(dat_vo2$time) ## chr [1:330] &quot; 00:05 &quot; &quot; 00:10 &quot; &quot; 00:15 &quot; &quot; 00:20 &quot; &quot; 00:25 &quot; ... 6.5.2 Solution First, let me create a carbon copy of the data dat_vo2, so that I can modify the original data, and keep the carbon copy for explanation and illustration. dat_vo2_copy &lt;- dat_vo2 Use the mutate() function and the as.numeric function. You will learn the mutate () function more in Recipe 6.11. # 4 in 1 processing dat_vo2 &lt;- dat_vo2 %&gt;% mutate (time = time %&gt;% str_squish() %&gt;% # function strips any whitespaces ms() %&gt;% # convert to minutes and seconds as.period(unit = &quot;sec&quot;) %&gt;% # converts entirely to seconds as.numeric ()) # strips the S symbol to make it a number time bf vo2_norm rer vo2 vco2 ve hr 5 37 21.4 0.93 1371 1272 46 119 10 58 2.5 0.84 159 133 12 120 15 30 23.5 0.74 1506 1110 35 121 20 34 22.4 0.86 1437 1229 43 123 25 23 15.6 0.73 1004 735 22 124 30 27 30.5 0.76 1960 1489 48 124 6.5.3 Discussion Notice in the function above, I chained a series of steps together, using the pipe, %&gt;%, function. Alternatively, I could do it in separate steps, and we can take a look at how each step changed the appearance of the time variable. Let me illustrate each step using the carbon copy data dat_vo2_copy. # First, removes whitespaces around the time variable time_mutate &lt;- dat_vo2_copy %&gt;% mutate (time = time %&gt;% str_squish()) time bf vo2_norm rer vo2 vco2 ve hr 00:05 37 21.4 0.93 1371 1272 46 119 00:10 58 2.5 0.84 159 133 12 120 00:15 30 23.5 0.74 1506 1110 35 121 00:20 34 22.4 0.86 1437 1229 43 123 00:25 23 15.6 0.73 1004 735 22 124 00:30 27 30.5 0.76 1960 1489 48 124 # Second, convert to minutes and seconds time_mutate &lt;- dat_vo2_copy %&gt;% mutate (time = time %&gt;% str_squish()%&gt;% ms()) time bf vo2_norm rer vo2 vco2 ve hr 325 27M 5S 55 45.31 1.07 2900 3100 112 194 326 27M 10S 57 45.33 1.03 2901 3000 111 195 327 27M 15S 52 44.61 1.06 2855 3035 111 194 328 27M 20S 59 46.50 1.04 2976 3100 112 197 329 27M 25S 60 45.14 1.07 2889 3085 113 196 330 27M 30S 61 46.00 1.05 2944 3093 114 195 # Third, converts entirely to seconds time_mutate &lt;- dat_vo2_copy %&gt;% mutate (time = time %&gt;% str_squish()%&gt;% ms() %&gt;% as.period(unit = &quot;sec&quot;)) time bf vo2_norm rer vo2 vco2 ve hr 325 1625S 55 45.31 1.07 2900 3100 112 194 326 1630S 57 45.33 1.03 2901 3000 111 195 327 1635S 52 44.61 1.06 2855 3035 111 194 328 1640S 59 46.50 1.04 2976 3100 112 197 329 1645S 60 45.14 1.07 2889 3085 113 196 330 1650S 61 46.00 1.05 2944 3093 114 195 # Fourth, strips the S symbol to make it a number, and assign it to object time_mutate &lt;- dat_vo2_copy %&gt;% mutate (time = time %&gt;% str_squish()%&gt;% ms() %&gt;% as.period(unit = &quot;sec&quot;) %&gt;% as.numeric ()) time bf vo2_norm rer vo2 vco2 ve hr 325 1625 55 45.31 1.07 2900 3100 112 194 326 1630 57 45.33 1.03 2901 3000 111 195 327 1635 52 44.61 1.06 2855 3035 111 194 328 1640 59 46.50 1.04 2976 3100 112 197 329 1645 60 45.14 1.07 2889 3085 113 196 330 1650 61 46.00 1.05 2944 3093 114 195 6.6 Split Numeric Variable into Categories 6.6.1 Problem Remember, each stage in VO2 testing is 3:30min (210sec) long, and you collected data in 5sec intervals. You want to split the time variable of the dat_vo2 dataset into chunks of 210 sec, and create a new variable called stage. You will learn the mutate () function more in Recipe 6.11. I will not explain the cut_interval function, other than to say that the length argument is used to specify the range of evenly spaced values to categorize over. 6.6.2 Solution dat_vo2 &lt;- dat_vo2 %&gt;% mutate (stage = cut_interval(time, length = 210, labels = FALSE)) time bf vo2_norm rer vo2 vco2 ve hr stage 5 37 21.4 0.93 1371 1272 46 119 1 10 58 2.5 0.84 159 133 12 120 1 15 30 23.5 0.74 1506 1110 35 121 1 20 34 22.4 0.86 1437 1229 43 123 1 25 23 15.6 0.73 1004 735 22 124 1 30 27 30.5 0.76 1960 1489 48 124 1 6.6.3 Discussion Why chunks of 210 sec? Vo2 data analysis, requires you to find the average values of the last 30s of each treadmill testing stage. Based on your Autumn School lessons, recall that each stage is 3 min 30 sec long or 210 sec. When doing data analysis, there is an amount of pre-planning on how to get the desired end product. There is no magic pill, the more analysis you do, the more short cuts you know. 6.7 Spreading 6.7.1 Problem You want to make your data wider, in this instance let us look at the dat_fms dataset. You want to have one column indicating the left FMS score, and one indicating the right FMS score. The caveat is that because some tasks in the FMS do not have left and right, we need to remove the tasks in the FMS without a left and right. In this case, we will use the filter() function, which will be discussed in Recipe 6.12. dat_fms_sub &lt;- dat_fms %&gt;% filter (side != &quot;c&quot;) 6.7.2 Solution dat_wide &lt;- dat_fms_sub %&gt;% # original data pivot_wider(names_from = &quot;side&quot;, values_from = &quot;score&quot;) task l r hurdle 2 2 lunge 3 3 leg_raise 2 1 shd_mob 1 2 rot_stab 2 2 6.8 Gathering 6.8.1 Problem You want to make your data longer. In this instance, if you have for example a left and right FMS column and you want to bring all into one column, you use the pivot_longer() function. 6.8.2 Solution dat_long &lt;- dat_wide %&gt;% # original data pivot_longer(cols = c(&quot;l&quot;, &quot;r&quot;), names_to = &quot;side&quot;, values_to = &quot;score&quot;) task side score hurdle l 2 hurdle r 2 lunge l 3 lunge r 3 leg_raise l 2 leg_raise r 1 shd_mob l 1 shd_mob r 2 rot_stab l 2 rot_stab r 2 6.9 Rename values of a variable 6.9.1 Problem You want to rename some values, either because it is too long, too short, or for other reasons. In this instance, in the dat_fms dataset, you want to call l, left, and r, right. 6.9.2 Solution Use the mutate() function and the recode() function. You will learn the mutate () function more in Recipe 6.11. dat_fms &lt;- dat_fms %&gt;% mutate (side = recode (side, # the variable name &quot;l&quot; = &quot;left&quot;, # old label = new label &quot;r&quot; = &quot;right&quot;)) # old label = new label task side score squat c 3 hurdle left 2 hurdle right 2 lunge left 3 lunge right 3 leg_raise left 2 leg_raise right 1 shd_mob left 1 shd_mob right 2 rot_stab left 2 rot_stab right 2 push_up c 1 6.10 Creating factors 6.10.1 Problem You want to create an order in the values of a variable - like small, medium, large. 6.10.2 Solution # Order of values I desire new_lvls &lt;- c( &quot;push_up&quot;,&quot;squat&quot;, &quot;rot_stab&quot;, &quot;hurdle&quot;, &quot;lunge&quot;, &quot;leg_raise&quot;, &quot;shd_mob&quot;) dat_fms_relvl &lt;- dat_fms %&gt;% mutate (task = factor (task, levels = new_lvls)) 6.10.3 Discussion Why do you need to convert categorical variables to factors? For visualization, the simple reason is that it allows you to control the order in which items appear first to last. Of course, it has important statistical reasons, of which we do not discuss presently. # Without factor ggplot(dat_fms) + geom_col(aes(x = task, y = score, fill = side), position = &quot;dodge&quot;, color = &quot;black&quot;) # With factor new levels ggplot(dat_fms_relvl) + geom_col(aes(x = task, y = score, fill = side), position = &quot;dodge&quot;, color = &quot;black&quot;) Figure 6.3: Barplots of FMS score on original dat_fms (top); and new dat_fms_relvl when with modified the task variable to be a factor, with new levels (bottom). 6.11 Making a new variable 6.11.1 Problem You want to create a new column which involves some math between columns 6.11.2 Solution Example, you want to create a column called ratio in the dat_vo2 dataset, by dividing vo2 by vco2. dat_vo2 &lt;- dat_vo2 %&gt;% mutate (ratio = vo2/vco2) time bf vo2_norm rer vo2 vco2 ve hr stage ratio 5 37 21.4 0.93 1371 1272 46 119 1 1.08 10 58 2.5 0.84 159 133 12 120 1 1.20 15 30 23.5 0.74 1506 1110 35 121 1 1.36 20 34 22.4 0.86 1437 1229 43 123 1 1.17 25 23 15.6 0.73 1004 735 22 124 1 1.37 30 27 30.5 0.76 1960 1489 48 124 1 1.32 6.11.3 Discussion There are many math operations you can do including subtraction (-), multiplication (*), addition (+), exponentiation/power to the power of 2 (^2). Let us go crazy and try some random creation of new variables. dat_vo2_crazy &lt;- dat_vo2 %&gt;% mutate (vo2_power = vo2^3,# vo2 powered to 3 vco2_mod = vco2/3, # vco2 divied by 3 junk = (vo2+ vco2)/ (hr + bf))# divided the sum of vo2 and vco2, and sum of hr and bf time bf vo2_norm rer vo2 vco2 ve hr stage ratio vo2_power vco2_mod junk 5 37 21.4 0.93 1371 1272 46 119 1 1.08 2576987811 424.00 16.94 10 58 2.5 0.84 159 133 12 120 1 1.20 4019679 44.33 1.64 15 30 23.5 0.74 1506 1110 35 121 1 1.36 3415662216 370.00 17.32 20 34 22.4 0.86 1437 1229 43 123 1 1.17 2967360453 409.67 16.98 25 23 15.6 0.73 1004 735 22 124 1 1.37 1012048064 245.00 11.83 30 27 30.5 0.76 1960 1489 48 124 1 1.32 7529536000 496.33 22.84 You can even create a new variable, which reflects the present row number (row_id). This row number reflects the number of 5 sec VO2 windows. If there is 10 sec of data collected, there will be two row numbers, Really quite useful for VO2 analysis and cleaning. Here, inside the mutate() function, I will be using the function row_number() to get the respective number for each row. dat_vo2 &lt;- dat_vo2 %&gt;% mutate (row_id = row_number()) time bf vo2_norm rer vo2 vco2 ve hr stage ratio row_id 5 37 21.4 0.93 1371 1272 46 119 1 1.08 1 10 58 2.5 0.84 159 133 12 120 1 1.20 2 15 30 23.5 0.74 1506 1110 35 121 1 1.36 3 20 34 22.4 0.86 1437 1229 43 123 1 1.17 4 25 23 15.6 0.73 1004 735 22 124 1 1.37 5 30 27 30.5 0.76 1960 1489 48 124 1 1.32 6 6.12 Filtering Filtering is removing rows you do not want and keeping rows you want based on some condition(s). In Recipe 6.3, you learnt the slice() function. That is for really simple filtering. The filter() function you will learn here gives you more flexibility. Filtering deals with keeping or throwing out rows of data. Keeping or throwing out columns of data requires the select() function, which you learnt in Recipe 6.3. 6.12.1 Keep rows you want based on condition 6.12.1.1 Problem In the dat_fms dataset, you want to keep rows that have side == \"left\" (i.e. only rows where the side value equals left). Note the ==, double equal sign, instead of the usual =. In this short book, I will not go at length to explain why R is so difficult, only that I ask you to obey the rules of the language. 6.12.1.2 Solution fms_left &lt;- dat_fms %&gt;% filter (side == &quot;left&quot;) task side score hurdle left 2 lunge left 3 leg_raise left 2 shd_mob left 1 rot_stab left 2 6.12.2 Keep rows based on a numerical range You want to keep the data when a variable is within a certain window range. Let us use the dat_vo2 dataset. Let us see the range of values of the variable ve. hist (dat_vo2$ve) 6.12.2.1 Problem Say I want to keep rows where 1) ve is less than 80, 2) ve more than 40, and 3) ve is between 40 to 80. 6.12.2.2 Solution Notice for each graph, how the minimum and maximum values have been clipped off. # Keep ve less than 80 dat_vo2_filt &lt;- dat_vo2 %&gt;% filter (ve &lt; 80) hist (dat_vo2_filt$ve) # Keep ve lmore than 40 dat_vo2_filt &lt;- dat_vo2 %&gt;% filter (ve &gt; 40) hist (dat_vo2_filt$ve) # Keep ve between 40 to 80 dat_vo2_filt &lt;- dat_vo2 %&gt;% filter (ve &gt; 40 &amp; ve &lt; 80) hist (dat_vo2_filt$ve) 6.12.3 Discussion filter() works really when you want to throw out or keep rows of data based on some ranges or criteria of the variables you have. When you want to keep rows of data based on the row number, use slice (). See also Recipe 6.3. 6.13 Global summary 6.13.1 Problem You want to find the total FMS score across all sides and tasks 6.13.2 Solution In the dat_fms dataset, we want to use the summarize () function. dat_fms %&gt;% summarize (total_score = sum (score)) ## total_score ## 1 24 I dare you to find an easier way to calculate such scores in one line of code. That is one reason why I use a programming language like R. It is fast!!! 6.13.3 Discussion We can also go berserk by trying out different summary functions, like mean (), median (), min() (minimum value), max (maximum value). fms_summ &lt;- dat_fms %&gt;% summarize (total_score = sum (score), mean_score = mean (score), median_score = median (score), min_score = min (score), max_score = max(score)) total_score mean_score median_score min_score max_score 24 2 2 1 3 6.14 Group-by summary 6.14.1 Problem You want to perform the same summary function for each chunk of group. For example, the FMS is typically scored by taking the lower of the two values of left and right for each task. In side, we have three values, c, left and right. The minimum of c is the same value itself. 6.14.2 Solution In the dat_fms dataset, we want to use the group_by() and summarize () function.The code below reads as: for each task, tell me the lowest value. For the task of leg raise, the lower of the two values is 1. And you will indeed see that has been created. fms_summ &lt;- dat_fms %&gt;% group_by(task) %&gt;% summarize (lower_score = min (score)) ## `summarise()` ungrouping output (override with `.groups` argument) task lower_score hurdle 2 leg_raise 1 lunge 3 push_up 1 rot_stab 2 shd_mob 1 squat 3 6.14.3 Discussion Why do you need to learn to create summaries? It is the basis for generating plots easily. Let us look at the dat_vo2 dataset. Remember in your lessons, the last 30 sec of each 3 min 30 sec complete stage is discarded. That means that I want to throw away the data interval between 3:00 to 3:30 min for every stage. Thereafter, for the complete stage, the last 30 sec of each 3 min interval is then averaged for further analysis. This means keeping data between 2:30 to 3:00 min of each stage. That corresponds to the last six rows of each stage (i.e. rows 31 to 36 of each stage). Try to think why i selected these row numbers! For the last stage, there may be the chance that it is incomplete. Based on Kellys lesson, you will need to extract the last 30 sec (i.e. last six rows) of this last incomplete stage. I then want to average all my variables over these 6 rows per stage. I should end up with a dataframe that has 8 rows given 8 stages, one for each stage in this example. dat_vo2_summ &lt;- dat_vo2 %&gt;% group_by(stage) %&gt;% # for each group mutate (row_id = row_number()) %&gt;% filter (row_id &lt; 37) %&gt;% slice_tail (n = 6) %&gt;% summarise (bf = mean (bf), vo2_norm = mean (vo2_norm), rer = mean (rer), vo2 = mean (vo2), vco2 = mean (vco2), ve = mean (ve), hr = mean (hr)) ## `summarise()` ungrouping output (override with `.groups` argument) Table 6.1: Stage by stage VO2 analysis stage bf vo2_norm rer vo2 vco2 ve hr 1 30.67 31.97 0.87 2052.83 1777.83 55.17 136.50 2 34.67 34.60 0.88 2222.17 1957.50 59.33 147.00 3 34.67 37.42 0.91 2401.83 2191.33 66.67 161.33 4 38.00 37.83 0.95 2429.00 2312.50 71.17 172.17 5 44.00 41.67 1.00 2675.00 2686.00 85.67 178.50 6 45.67 43.85 1.06 2813.67 2981.17 99.83 185.83 7 54.50 45.50 1.09 2920.17 3195.83 110.33 192.33 8 57.33 45.48 1.05 2910.83 3068.83 112.17 195.17 6.15 Merge two tables together 6.15.1 Problem You want to combine two tables together, ensuring that each row is linked appropriately. For example, you want to combine your dat_vo2_summ summary data with the dat_vo2_stage table which contains the RPE and blood lactate values. 6.15.2 Solution Use the inner_join function, with the by key as the common identifier that must be in both dataframes. dat_vo2_comb &lt;- dat_vo2_summ %&gt;% inner_join(dat_vo2_stage, by = &quot;stage&quot;) stage bf vo2_norm rer vo2 vco2 ve hr speed rpe lactate 1 30.67 31.97 0.87 2052.83 1777.83 55.17 136.50 1 10 1.0 2 34.67 34.60 0.88 2222.17 1957.50 59.33 147.00 2 11 1.5 3 34.67 37.42 0.91 2401.83 2191.33 66.67 161.33 3 12 1.8 4 38.00 37.83 0.95 2429.00 2312.50 71.17 172.17 4 13 2.5 5 44.00 41.67 1.00 2675.00 2686.00 85.67 178.50 5 14 6.0 6 45.67 43.85 1.06 2813.67 2981.17 99.83 185.83 6 15 7.7 7 54.50 45.50 1.09 2920.17 3195.83 110.33 192.33 7 16 9.0 8 57.33 45.48 1.05 2910.83 3068.83 112.17 195.17 8 17 10.0 6.15.3 Discussion It is common sense, that if we want to join two tables, there must be some rules. First, if we want to join two tables side by side left-right, the number of rows must match. Second, there must be a way the computer knows how to join, much like a key and a keyhole. The key is the column to join by, in this example, stage. In the dat_vo2_summ there is the stage variable with identical number of levels 1-8, and the same variable appears in dat_vo2_stage. You dont have to worry if after merging, the data is sorted correctly, if you follow these rules. 6.16 Learning check From your learning check in 5.4, open up your practice_script.R. You should already have the codes to import the data/Athlete_1_treadmill.xlsx file, and label the data called dat. Rename the columns of dat to be (\"time\", \"bf\", \"vo2_norm\", \"rer\", \"vo2\", \"vco2\", \"ve\", \"hr\"), respectively. See Recipe 6.2. Remove the first row of the dat data, as it is useless. See Recipe 6.3. Convert the variable time of dat into numeric seconds, and all other variables to numeric. See Recipe 6.5 and 6.4, respectively. Create a variable called stage, where each stage represents 3:30 min worth of VO2 data. See Recipe 6.6. For each stage, create a variable called row_id, which essentially represents the number of 5 sec windows in each stage. See Recipe 6.11 and 6.14. For each stage, remove the data between 3:00 to 3:30min. See Recipe 6.14 and 6.12.2. For each stage, keep the last six rows of data. See Recipe 6.14 and 6.3. For each stage, calculate for all variables for the mean of the last six rows of data. See Recipe 6.14 and 6.13. Save this cleaned data set into the data/ folder called Athlete_1_treadmill_clean.xlsx. Go into this folder physically, and see this new excel file is there and open it. See Recipe 5.3 "]]
