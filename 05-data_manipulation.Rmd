# Data manipulation {#WRANGLE}

The power of R lies in its ability to do things to data. Here, you will learn several techniques that is essential in everyday sports science and coaching professions.

## Download and load packages {-}

```{r, message=FALSE, warning=FALSE}
if (!require("pacman")) install.packages("pacman")
pacman::p_load(tidyverse, # All purpose wrangling for dataframes
               openxlsx) # moving average for vo2

```



## Import data {-}

Let's load the files from the `data` folder into the work space again. 

```{r message=FALSE, warning=FALSE}

dat_fms <-  read.xlsx (xlsxFile = "data/groupFMS.xlsx")

bad_leg_accl <-  read.xlsx (xlsxFile = "data/rightleg_imu.xlsx")

good_leg_accl<-  read.xlsx (xlsxFile = "data/leftleg_imu.xlsx")

```

### Let us see the data {-}

**Table containing the group FMS data** 

This is a table representing the individual FMS scores of every athlete within a team.

```{r, echo = FALSE}
dat_fms %>%
  knitr::kable () %>%
  kableExtra::scroll_box(width = "100%", height = "500px")
```

**Data contains the IMU signals from a drop-land task of the bad leg**

```{r, echo = FALSE}
bad_leg_accl %>%
  knitr::kable () %>%
  kableExtra::scroll_box(width = "100%", height = "500px")
```

**Data contains the IMU signals from a drop-land task of the good leg**

```{r, echo = FALSE}
good_leg_accl %>%
  knitr::kable () %>%
  kableExtra::scroll_box(width = "100%", height = "500px")
```


## Tidy data {#WRANGLE-TIDY-DATA}

```{r, echo = FALSE}
vembedr::embed_youtube("LKftcxMdqm8", height = 400)
```


You can represent the same underlying data in multiple ways. The example below shows the same data organised in four different ways. This dataset is **not the data you loaded**, but rather came with the `tidyverse` package. Each dataset shows the same values of four variables *country*, *year*, *population*, and *cases*, but each dataset organises the values in a different way.

```{r}
table1
table2
table3

# Spread across two tables
table4a  # cases
table4b  # population
```

These are all representations of the same underlying data, but they are not equally easy to use. One dataset, the tidy dataset, will be much easier to work with. 

There are three interrelated rules which make a dataset tidy:

1.  Each variable must have its own column.
1.  Each observation must have its own row.
1.  Each value must have its own cell.

Figure \@ref(fig:tidy-structure) shows the rules visually.

```{r tidy-structure, echo = FALSE, out.width = "100%", fig.cap = "Following three rules makes a dataset tidy: variables are in columns, observations are in rows, and values are in cells."}
knitr::include_graphics("images/chapter-5/tidy-1.png")
```

These three rules are interrelated because it's impossible to only satisfy two of the three. 

In this example, only `table1` is tidy. It's the only representation where each column is a variable.

Why ensure that your data is tidy? There are two main advantages:

1.  There's a general advantage to picking one consistent way of storing
    data. If you have a consistent data structure, it's easier to learn the
    tools that work with it because they have an underlying uniformity.
    
1.  There's a specific advantage to placing variables in columns because
    most of R functions work with data in the tidy format. That makes transforming 
    tidy data feel particularly natural.
    
The principles of tidy data seem so obvious that you might wonder if you'll ever encounter a dataset that isn't tidy. Unfortunately, however, most data that you will encounter will be untidy. There are two main reasons:

1.  Most people aren't familiar with the principles of tidy data, and it's hard
    to derive them yourself unless you spend a _lot_ of time working with data.
    
2.  Data is often organised to facilitate some use other than analysis. For 
    example, data is often organised to make entry as easy as possible.
    
This means for most real analyses, you'll need to do some tidying. The first step is always to figure out what the variables and observations are. Sometimes this is easy; other times you'll need to consult with the people who originally generated the data. 
The second step is to resolve one of two common problems:

1. One variable might be spread across multiple columns.

2. One observation might be scattered across multiple rows.

Typically a dataset will only suffer from one of these problems; it'll only suffer from both if you're really unlucky! To fix these problems, you'll need the two most important functions in tidyr: `pivot_wider()` in Recipe \@ref(WRANGLE-SPREAD) and `pivot_longer()` in Recipe \@ref(WRANGLE-GATHER) below.

## Selecting columns {#WRANGLE-SELECT}

```{r, echo = FALSE}
vembedr::embed_youtube("w3NWqv0yzRw", height = 400)
```

### Problem

You want to keep or remove a specific column or a range of columns. 

### Solution

To keep based on the column names, use the `select ()` function. When keying in the name of the column variables you want to keep, you do not really need to use the `""`. This means, you can type the names you want like the following: `select(time_s, mx_microT)`. In the example below, I used `""` to surround the variable names. I did this because as previously mentioned in \@ref(INPUT-FILE), the symbol `/` has a special, **irritating** meaning in R. So, avoid having such symbols anyway in your files, but for now, I have shown you how to overcome this problem.

```{r }

# This selects the vertical acceleration signal of the IMU of the bad leg

bad_vertical_accl <- bad_leg_accl %>%
  select ("highg_az_m/s/s")
```

```{r, echo = FALSE}
bad_vertical_accl %>%
  head() %>%
  knitr::kable (digits = 2)
```


```{r }

# This selects the vertical acceleration signal of the IMU of the good leg

good_vertical_accl <- good_leg_accl %>%
  select ("highg_az_m/s/s")
```

```{r, echo = FALSE}
good_vertical_accl %>%
  head() %>%
  knitr::kable (digits = 2)
```

### Discussion

Notice in the function above, I chained a series of steps together, using the pipe, `%>%`, function. For now, let's just accept this as a more efficient way of writing code. 

## Gathering {#WRANGLE-GATHER}

```{r, echo = FALSE}
vembedr::embed_youtube("-ouaXbHYaFc", height = 400)
```

### Problem

You want to reshape the structure of your data from wide to long. This is tidy data. In the data `dat_fms`, you want to merge the 12 FMS task columns into one, and not the `id` column, indicating the 12 FMS tasks and sides. For this, you can use the `pivot_longer()` function. 

### Solution

```{r }
dat_long <- dat_fms %>% # original data
  pivot_longer(cols = -id,
              names_to = "task",
              values_to = "score")
```

```{r, echo = FALSE}
dat_long %>%
  knitr::kable (digits = 2) %>%
  kableExtra::scroll_box(width = "100%", height = "500px")
```

## Spreading {#WRANGLE-SPREAD}

```{r, echo = FALSE}
vembedr::embed_youtube("qM8FRIXwZ7M", height = 400)
```

### Problem

You want to reshape the structure of your data from long to wide. So lets reverse the `dat_long` data we created in Recipe \@ref(WRANGLE-GATHER).

### Solution

```{r }
dat_wide <- dat_long %>% # original data
  pivot_wider(names_from = "task",
              values_from = "score")

```

```{r, echo = FALSE}
dat_wide%>%
  knitr::kable (digits = 2)
```


## Making a new variable {#WRANGLE-NEW-VARIABLES}

```{r, echo = FALSE}
vembedr::embed_youtube("24ocZMvvSUc", height = 400)
```

### Problem

You want to create new column(s) which may involve some manipulation or math within and between columns

### Solution

#### Example 1

In the `dat_long` data, the `task` column contains two pieces of information. Side (right or left) for tasks with bilateral involvement, and the task itself. 

You want to create two new columns. A column called `side` which contains `left` and `right` where needed, and if not, a neutral term such as `central`. Another column you want to create is actually a replacement of the old column, `task`. You want to strip the `R_` and `L_` suffixes of the current `task` values.

The function `mutate` is useful to create new variables. Inside mutate, you can call many other functions to perform specific manipulations. Three examples below are `case_when`, `str_detect`, `str_remove_all`. `case_when` is useful for renaming the names of variables depending if some conditions are met. `str_detect` is read out loud as "string detect", and is useful for detecting the presence of specific character patterns in a string. `str_remove_all` is read out loud as "string remove all", and is useful for removing the  presence of specific character patterns from a string.

```{r }
# The below code can be read out loud as "create a new variable called side. When task contains the 'R_' character, put a value of 'right' in side. When task contains the 'L_' character, put a value of 'left' in side. When task contains neither 'R_' nor 'L_', put a value of 'central' in side ".

dat_long <-  dat_long %>%
  mutate (
    side = case_when(
    str_detect(task, "R_") ~ "right",
    str_detect(task, "L_") ~ "left",
    TRUE ~ "central"
  )) 

# The below code can be read out loud as "create a new variable called task, and replace the old task. Strip all values inside task, of the patterns 'R_' or 'L_'.

dat_long <- dat_long %>%
  mutate (task = str_remove_all(task, "R_|L_"))

```


```{r, echo = FALSE}
head(dat_long)%>%
  knitr::kable (digits = 2)
```


#### Example 2

There are many math operations you can do including subtraction (`-`), multiplication (`*`), addition (`+`), exponentiation/power to the power of 2 (`^2`). 

Let's use the `dat_wide` data. Say for example, we want to add up the individual scores for all tasks, for all athletes.

```{r }

dat_wide <-  dat_wide  %>%
  mutate (total = 
            squat + R_hurdle + L_hurdle + 
            R_lunge + L_lunge + R_shd_mob +
            L_shd_mob + R_leg_raise + L_leg_raise +
            push_up + R_rot_stab + L_rot_stab)
            
```

```{r, echo = FALSE}
head(dat_wide)%>%
  knitr::kable (digits = 2) 
```


For the IMU data, you can automatically find the maximum value of a very long data sequence, and use these values to provide an index of landing impact symmetry.

```{r}

# Maximal bad leg impact value
max_bad_ampl <- max(bad_vertical_accl)

# Maximal good leg impact value
max_good_ampl <- max(good_vertical_accl)

```
```{r}

# Symmetry index 

symmmetry_index <- 
  ((2* (max_bad_ampl - max_good_ampl))/(max_bad_ampl + max_good_ampl)) * 100


symmmetry_index

```



## Creating factors {#WRANGLE-CHARACTERS-2-FACTORS}

```{r, echo = FALSE}
vembedr::embed_youtube("b47cJ_tTA2U", height = 400)
```

### Problem

Factors are a special way of treating variables that are `characters` or words. Words have no inherent order to them. Factors create order, such as small comes first, medium next, and large last. 

Let's use the `dat_long` data, and make `task` a factor, using the function `factor` inside `mutate`. How does R naturally create the order? If you guessed correctly, it orders it alphabetically. 

```{r}
dat_long <- dat_long %>%
  mutate (task = factor (task))

levels (dat_long$task)
```

### Solution

If you want to create your own order. This is how you do it. See the new ordering now.

```{r}
# Order of values I desire
new_lvls <- c( "push_up","squat", "rot_stab", "hurdle", "lunge", "leg_raise",  "shd_mob")

dat_long_relvl  <- dat_long %>%
  mutate (task = factor (task, levels = new_lvls))

levels (dat_long_relvl$task)
```

### Discussion

Why do you need to convert categorical variables to factors? For visualization, the simple reason is that it allows you to control the order in which items appear first to last. Of course, it has important statistical reasons, of which we do not discuss presently.

(ref:cap-FIG-BAR-GRAPH-FACTOR-EFFECTS) Barplots of the FMS score using R natural ordering (top); and using our custom ordering on the `task` variable (bottom).

```{r FIG-BAR-GRAPH-FACTOR-EFFECTS, fig.show="hold", fig.cap="(ref:cap-FIG-BAR-GRAPH-FACTOR-EFFECTS)"}
# With old factor levels

dat_long %>%
  group_by(id, task) %>%
  mutate (score = min (score)) %>%
  ggplot() +
  geom_col(aes(x = task, y = score, fill = id), position = "dodge", color = "black") 

# With factor new levels

dat_long_relvl %>%
  group_by(id, task) %>%
  mutate (score = min (score)) %>%
  ggplot() +
  geom_col(aes(x = task, y = score, fill = id), position = "dodge", color = "black") 

```

## Filtering {#WRANGLE-FILTER}

```{r, echo = FALSE}
vembedr::embed_youtube("cJl2HVMsKYE", height = 400)
```

Filtering is removing rows you do not want and keeping rows you want based on some condition(s). Filtering deals with keeping or throwing out **rows** of data. Keeping or throwing out columns of data requires the `select()` function, which you learnt in Recipe \@ref(WRANGLE-SELECT).

### Keep rows you want based on condition {#WRANGLE-FILTER-KEEP-CHARACTER}

#### Problem

In the `dat_fms` dataset, you want to keep the row which belongs to athlete a. To do that you need to use the `filter` function to selection `id == "athlete_a"`. Note the `==`, double equal sign, instead of the usual `=`. In this short book, I will not go at length to explain why R is so difficult, only that I ask you to obey the rules of the language. 

#### Solution

```{r }

athlete_a <- dat_fms %>%
  filter (id == "athlete_a") 
```

```{r, echo = FALSE}
athlete_a %>%
  knitr::kable (digits = 2)
```


## Group-by summary {#WRANGLE-SUMMARISE}

```{r, echo = FALSE}
vembedr::embed_youtube("9lSv-NjmBWQQ", height = 400)
```

### Problem

For each athlete and task, you want to find the minimum value between right and left side, as that is how the FMS is scored.

### Solution

In the `dat_long` data set, we want to use the `summarise ()` function. Notice how I use the `group_by` function first. I want to perform the same task repeatedly for each subgroup of athletes and tasks.

To find the minimum, use the `min` function.

```{r }
fms_sum <- dat_long %>%
  group_by(id, task) %>%
  summarise (score = min (score))

```

```{r, echo = FALSE}
fms_sum %>%
  knitr::kable (digits = 2) %>%
  kableExtra::scroll_box(width = "100%", height = "500px")
```

I dare you to find an easier way to calculate such scores in one line of code. That is one reason why I use a programming language like R. It is fast!!!

### Discussion

We can also go berserk by trying out different summary functions, like `mean ()`, `median ()`, `min()` (minimum value), `max` (maximum value). The function `n()` is a really useful one to count the number of rows. If your rows indicate the number of subjects, `n()` essentially counts the number of rows in each subgroup.

```{r }

fms_sum <- dat_long %>%
  group_by(id, task) %>%
  summarize (total_score = sum (score),
             mean_score = mean (score),
             median_score = median (score),
             min_score = min (score),
             max_score = max(score),
             count = n()) 
```

```{r, echo = FALSE}
fms_sum %>%
  knitr::kable (digits = 2) %>%
  kableExtra::scroll_box(width = "100%", height = "500px")
```

If you want to perform two consecutive groupby summary tasks, first identify the lower of the two bilateral scores for tasks with bilateral assessments, then count the number of athletes who scored `0`, `1`, `2`, or `3` for each FMS task, you can accomplish this like below.

```{r }

fms_sum <- dat_long %>%
  group_by(id, task) %>%
  summarise (score = min (score)) %>%
  group_by (task, score) %>%
  summarise (count = n())

```

```{r, echo = FALSE}
fms_sum %>%
  knitr::kable (digits = 2) %>%
  kableExtra::scroll_box(width = "100%", height = "500px")
```


## Learning check {#WRANGLE-LEARNING-CHECK}

```{r, echo = FALSE}
vembedr::embed_youtube("Uj7Jzi0BU2M", height = 400)
```

1. From your learning check in \@ref(INPUT-LEARNING-CHECK), open up your `practice_script.R`. You should already have the codes to import three excel files of `data/groupFMS.xlsx`, `data/rightleg_imu.xlsx`, and `data/leftleg_imu.xlsx`, and assign it to appropriately named objects.

2. From the group FMS data, create a long dataframe with three columns, `id`, `task` and `score`. The `task` column contains the names of the FMS exercises, and the `score` column contains the values of the FMS exercises. See Recipe \@ref(WRANGLE-GATHER). Assign this long dataframe to an object called `dat_long`.

3. From the `dat_long` data, split the `task` column into two columns called `side` and `task`. See Recipe \@ref(WRANGLE-NEW-VARIABLES). Assign this modified dataframe to the same object called `dat_long`.

4. From the `dat_long` data, for FMS tasks with bilateral assessments, keep the score with the lower values. For FMS tasks with no bilateral assessments, keep that only score. Thereafter, count the number of athletes which scored a value of `0`, `1`, `2`, or `3` for each FMS task. Assign this result to an object called `fms_count`. See Recipe \@ref(WRANGLE-SUMMARISE).

5. From the `dat_long` data, for FMS tasks with bilateral assessments, keep the score with the lower values. For FMS tasks with no bilateral assessments, keep that only score. Thereafter, for each athlete, sum the score over the seven FMS tasks. Assign this result to an object called `fms_total`. See Recipe \@ref(WRANGLE-SUMMARISE).

6. From the `fms_total` data, find the group mean and standard deviation FMS score. Assign this result to an object called `fms_summary`. See Recipe \@ref(WRANGLE-SUMMARISE).

7. From the group FMS data, select only the row that belongs to `athlete_c`, and assign it to an object called `athlete_c`.

8. From the `athlete_c` data, create a long dataframe with three columns, `id`, `task` and `score`. The `task` column contains the names of the FMS exercises, and the `score` column contains the values of the FMS exercises. See Recipe \@ref(WRANGLE-GATHER). Assign this long dataframe to an object called `athlete_c_long`.

9. From the `athlete_c_long` data, split the `task` column into two columns called `side` and `task`. See Recipe \@ref(WRANGLE-NEW-VARIABLES). Assign this modified dataframe to the same object called `dat_long`.

10. Remember to save your file.

11. Download the solution to this learning check below.

```{r echo=FALSE}
downloadthis::download_file(
  path = "data/practice_manip.R",
  output_name = "Learning check 6 answers",
  output_extension = ".R",
  button_label = "Learning check 6 answers",
  button_type = "warning",
  has_icon = TRUE,
  icon = "fa fa-save"
 
)
```

